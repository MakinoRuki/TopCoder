SRM 645 Div1 Med
平面上N<=50个点V1，每次从a,b,c三个点中选一个点，将V1所有点关于这个点对称。重复此操作任意次。问能否把V1变为V2。
Solution：
首先变换之后点的大小顺序不变，因此先排个序。然后偶数次变换之后org和tar点之间的delta必然形如2*i*(A - B)+2*j*(A - C)。
如果是奇数次变换，则先将所有点关于A/B/C变换一次，然后转化成偶数次的情况。

SRM 645 Div2 Hard
n<=10^12个人，m<=50个field。游戏进行k<=50轮，每轮每个人把自己的token放到一个field上，然后选一个随机的field删掉。所有选这个field的人出局。
问最优策略下，k轮之后至少一个人存活的概率多大。
Solution：
不要把鸡蛋放到一个篮子里。每次均分是最优策略。然后用个map暴力dp。由于每次只会加进来最多2个状态，所以总状态数是O(n)的。一切暴力即可。

SRM 656 Div1 Med
有多少1-n(n<=10^6)的排列满足当且仅当下标idx在给定数组pos(size<=2500)时，p[idx]<p[idx+1]。答案mod 1e9+7。
Solution：
将排列分段。考察以每个pos[i]+1开始的递减序列。假设长度分别为a,b,c(a+b+c=n)。那么利用容斥原理，答案应该是
ans=C(n,a)*C(n-a,b)*C(n-a-b,c)-C(n,a+b)*C(n-a-b,c)-C(n,b+c)*C(n-b-c,a)+C(n,a+b+c)。
把最外面的项相同的合并，把这一项提出来，可以得到n^2的式子。

SRM 657 Div1 Med
给定多项式P(x)=x^d[0]*(x-1)^d[1]*(x-2)^d[2]*...*(x-n+1)^d[n-1](n<=10000)。问，不管x取何值均能整除P(x)的最大正整数是多少。答案mod 1e9+7。
Solution：
设答案d=p1^a1*p2^a2*...*px^ax。对每个素数pi，需要知道ai最大是多少。我们只需考察x属于[0,pi)的情况，设x=x0,则x0+m*p与x0情况相同。
因此枚举x[0,pi)，得到的幂次加和。但是还有pi的多次幂的情况，因此需要递归求解。
比如x=0时，取出的项是(x-0),(x-p),...(x-p^2),(x-p^2-p)，那么根据x=0还是x=p,p^2的幂次是不一样的。因此需要再次枚举x'[0,pi)，
得到的和的max值加到之前的结果里。

SRM 657 Div2 Hard
求一个[0,10^9)之间的整数x，满足P(x)=a*x^2+b*x+c能被10^9整除。
Solution：
被10^9整除，则能被2^9和5^9整除。枚举[0,5^9)之间的数，找到一个代入P(x)之后mod5^9=0的x。然后枚举10^9/5^9=2^9项，找一个能被2^9整除的数即是答案。

SRM 664 Div1 Easy
两堆石子A,B(A,B<=10^9)。执行K(K<=2*10^9)次操作，每次从大的一堆石子中取石子double小的一堆。问K次操作后小的一堆石子是多少。
Solution：
如果A<=B,则A->2*A,否则，A->A-B=A-(S-A)=2*A-S(此时2*A > S)。因此可以看成每次都是把A乘2后％S。那么就计算(A*2^K)%S。之后取A和S-A较小的一堆即可。

SRM 677 Div1 Easy
把(a,b)变成(A,B)(a,b,A,B<=10^9)，每次可以把两个数乘以2可以给两个数都加1。问最少步数。
Solution：
A一定为2^x * a + 2^y1 + 2^y2 + ...的形式，B同理。因此对于a＝b的情况，找出x的最大值。对于a!=b的情况，找出(A-B)/(a-b)。
然后注意一个坑，后面y1<=x。因此从小到大枚举2的幂次，超过x的部分全部用＋1。

SRM 683 Div1 Med
n(n<=10^5)个数，每次选两个，从集合中删掉，再把gcd和lcm加进去。问最后这些数和最大是多少。
数字生成方式：给定start,cnt数组，for i=1-|start| : for j=0-|cnt|-1 : add start[i]+j*d[i]。
Solution：
最后必然是每个素数的幂都从小到大排列。直接对每个数分解质因数，然后暴力填进n个数里。(复杂度？)

SRM 686 Div1 Med(strling)

SRM 697 Div1 Easy
给一个长度为n(n<=50)的数组b,1<=b[i]<=10。问是否存在一个长度为n的数组a，满足a[i] >= 2且a[i]互不相同且对于每个a[i],
a[i]^b[i]能被T/a[i]整除，其中T=a[1]*a[2]*...*a[i-1]*a[i+1]*...*a[n]。
Solution:
对于某个素数p，假设p^ri | a[i],则需要满足ri * bi <= S-ri(S=r1+r2+...+rn),也就是(bi+1)*ri<=S，也就是ri<=S/(bi+1)。
n个不等式左右相加，得到S<=S/(b1+1)+...S/(bn+1)。也就是1/(b1+1)+1/(b2+1)+...+1/(bn+1)>=1。
还有条件a[i]必须互不相同。如果b[i]互不相同，我们可以令ri=lcm(b+1)/(b[i]+1)。如果有b[i]相等，而1/(b1+1)+1/(b2+1)+...+1/(bn+1)=1,那么就无解。
否则，可以随便找个比较大的数，做到ri互不相等。

SRM 704 Div1 Med
n(n<=50)个在[0,k)(k<=10^9)之间的数组成一个序列，给出q(q<=1000)个询问，问满足乘积mod k = q[i]的序列有多少种。
Solution：
首先设n个数的乘积是X，那么X % k == q[i]条件是，gcd(X,k)==gcd(q[i],k)。那么我们可以dp出n个数乘积和k的gcd为d的方案数num。
同时，由于q[i]必然是在[0,k)之间的，那么可以求出y属于[0,k)之间，gcd(y,k)=d的cnt。这样，由于对称性，每个y的方案数就应该为num/cnt。
对于num，由于10^9以内的最大合数为735134400，有1344个因子，因此dp的复杂度大约为50*1344*1344。
对于cnt，求法是，对于d[i],cnt=k/d[i]-(cnt for d[j]，其中d[j] % d[i] == 0)。
还有一个优化就是，我们每次转移的时候如果从d[a]->d[b]那么d[b] % d[a] == 0必然成立。
因此可以把所有d[a]的倍数d[b]找出来，且预处理出d[a]->d[b]的方案数。

SRM 707 Div1 Med
问通过每次+a/*b，把s变成t的最小步数。其中a,b,s,t<=1e18。
Solution:
((s+an*a)*b + a1*a)*b + ... +a0*a = t。
重写一下就是(t-s*b^n)/a = sigma_i(ai * b^i)。那么就只要从小到大枚举n，求出对应式子右边的数的b进制表示法各位上的和。找一个最小的即可。
小trick：判断是否溢出：a*b/a=b。

SRM 711 Div1 Med
给一个长度为n(n<=50)的数组a，a[i]表示p[i]在X中的幂(a[i]<=50)。其中p[i]为第i大的素数。那么X=p[1]^a[1]+p[2]^a[2]+...+p[n]^a[n]。
问乘积为X的大于1的正整数序列方案数。
Solution:
由于序列长度最长为50*50，那么枚举序列长度，然后假设长度为L，就把每种prime放到序列中去。
dp[L]=C[L-1+a[1]][L-1]*C[L-1+a[2]][L-1]*...*C[L-1+a[n]][L-1]。
然后注意去掉有1的情况，就是dp[L]要减去C[L][L-1]*dp[L-1]+...+C[L][1]*dp[1]。

SRM 713 Div1 Easy
满足a^b=c^d且1<=a,b,c,d<=n<=10^9的方案数。
Solution:
a^b=c^d，底数只保留不可开方的数，那么必然可以写成a^x1b1=a^x2b2。其中a是一些素数幂的乘积。
那么a<=sqrt(10^9)时，可以枚举a,x1(<=30),x2(<=30)，然后方案数就是min(n/(lcm(x1,x2)/x1), n/(lcm(x1,x2)/x2))。
如果a>sqrt(10^9)，这意味着x1必须=x2。那么b1=b2。方案数就是n*n。
排除掉这一部分之后，在枚举的时候只要保证x1 != x2即可。
还有一点:由于a是一个不可以开方的底数，那么枚举的时候要保证它不是谁的幂。需要用一个set把枚举过的数及其power存起来以备以后检查。

SRM 733 Div1 Med
n个点的无向完全图，顶点编号1->n。问包含给定边集E的生成树有多少种。
Solution：
如果给定边集有环，则答案为0。
否则E可以分成一些集合，这些集合和在E之外的独立点共同构成k个components。
按照Cayley's formula的推导过程:
(https://haomaoer.wordpress.com/2016/12/02/caley%E5%85%AC%E5%BC%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AF%81%E6%98%8E/)
从n个点中每次选一个往其余k-1个集合的根连边，这样就是n*(k-1)*...*n*1。除以选边顺序(k-1)!。
再考虑一棵最终的生成树有n个根的情况所以除以n。答案就是n^(k-2)。
对于最开始的k个集合Sk，根的选择有|Sk|种。所以最终答案就是n^(k-2)*|S1|*...*|Sk|。

SRM 734 Div1 Easy
找到互素的pair(a,b)满足a^2+b^2<=r^2(r<=10^6)。
Solution：
枚举a，然后分解a的时候打表常优。
table[x]表示要分解x，下一个最小的素因子是多少。这个可以筛法求出。

TCO18 R2C Hard

TCO18 R3B Med(概率&期望)
Solution1(DP):
Solution2(Math):
