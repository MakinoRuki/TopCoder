SRM 645 Div1 Med
平面上N<=50个点V1，每次从a,b,c三个点中选一个点，将V1所有点关于这个点对称。重复此操作任意次。问能否把V1变为V2。
Solution：
首先变换之后点的大小顺序不变，因此先排个序。然后偶数次变换之后org和tar点之间的delta必然形如2*i*(A - B)+2*j*(A - C)。
如果是奇数次变换，则先将所有点关于A/B/C变换一次，然后转化成偶数次的情况。

SRM 645 Div2 Hard
n<=10^12个人，m<=50个field。游戏进行k<=50轮，每轮每个人把自己的token放到一个field上，然后选一个随机的field删掉。所有选这个field的人出局。
问最优策略下，k轮之后至少一个人存活的概率多大。
Solution：
不要把鸡蛋放到一个篮子里。每次均分是最优策略。然后用个map暴力dp。由于每次只会加进来最多2个状态，所以总状态数是O(n)的。一切暴力即可。

SRM 656 Div1 Med
有多少1-n(n<=10^6)的排列满足当且仅当下标idx在给定数组pos(size<=2500)时，p[idx]<p[idx+1]。答案mod 1e9+7。
Solution：
将排列分段。考察以每个pos[i]+1开始的递减序列。假设长度分别为a,b,c(a+b+c=n)。那么利用容斥原理，答案应该是
ans=C(n,a)*C(n-a,b)*C(n-a-b,c)-C(n,a+b)*C(n-a-b,c)-C(n,b+c)*C(n-b-c,a)+C(n,a+b+c)。
把最外面的项相同的合并，把这一项提出来，可以得到n^2的式子。

SRM 657 Div1 Med
给定多项式P(x)=x^d[0]*(x-1)^d[1]*(x-2)^d[2]*...*(x-n+1)^d[n-1](n<=10000)。问，不管x取何值均能整除P(x)的最大正整数是多少。答案mod 1e9+7。
Solution：
设答案d=p1^a1*p2^a2*...*px^ax。对每个素数pi，需要知道ai最大是多少。我们只需考察x属于[0,pi)的情况，设x=x0,则x0+m*p与x0情况相同。
因此枚举x[0,pi)，得到的幂次加和。但是还有pi的多次幂的情况，因此需要递归求解。
比如x=0时，取出的项是(x-0),(x-p),...(x-p^2),(x-p^2-p)，那么根据x=0还是x=p,p^2的幂次是不一样的。因此需要再次枚举x'[0,pi)，
得到的和的max值加到之前的结果里。

SRM 657 Div2 Hard
求一个[0,10^9)之间的整数x，满足P(x)=a*x^2+b*x+c能被10^9整除。
Solution：
被10^9整除，则能被2^9和5^9整除。枚举[0,5^9)之间的数，找到一个代入P(x)之后mod5^9=0的x。然后枚举10^9/5^9=2^9项，找一个能被2^9整除的数即是答案。

SRM 664 Div1 Easy
两堆石子A,B(A,B<=10^9)。执行K(K<=2*10^9)次操作，每次从大的一堆石子中取石子double小的一堆。问K次操作后小的一堆石子是多少。
Solution：
如果A<=B,则A->2*A,否则，A->A-B=A-(S-A)=2*A-S(此时2*A > S)。因此可以看成每次都是把A乘2后％S。那么就计算(A*2^K)%S。之后取A和S-A较小的一堆即可。

SRM 677 Div1 Easy
把(a,b)变成(A,B)(a,b,A,B<=10^9)，每次可以把两个数乘以2可以给两个数都加1。问最少步数。
Solution：
A一定为2^x * a + 2^y1 + 2^y2 + ...的形式，B同理。因此对于a＝b的情况，找出x的最大值。对于a!=b的情况，找出(A-B)/(a-b)。
然后注意一个坑，后面y1<=x。因此从小到大枚举2的幂次，超过x的部分全部用＋1。

SRM 683 Div1 Med
n(n<=10^5)个数，每次选两个，从集合中删掉，再把gcd和lcm加进去。问最后这些数和最大是多少。
数字生成方式：给定start,cnt数组，for i=1-|start| : for j=0-|cnt|-1 : add start[i]+j*d[i]。
Solution：
最后必然是每个素数的幂都从小到大排列。直接对每个数分解质因数，然后暴力填进n个数里。(复杂度？)

SRM 686 Div1 Med(strling)

SRM 697 Div1 Easy给一个长度为n(n<=50)的数组b,1<=b[i]<=10。问是否存在一个长度为n的数组a，满足a[i] >= 2且a[i]互不相同且对于每个a[i],
a[i]^b[i]能被T/a[i]整除，其中T=a[1]*a[2]*...*a[i-1]*a[i+1]*...*a[n]。
Solution:
对于某个素数p，假设p^ri | a[i],则需要满足ri * bi <= S-ri(S=r1+r2+...+rn),也就是(bi+1)*ri<=S，也就是ri<=S/(bi+1)。
n个不等式左右相加，得到S<=S/(b1+1)+...S/(bn+1)。也就是1/(b1+1)+1/(b2+1)+...+1/(bn+1)>=1。
还有条件a[i]必须互不相同。如果b[i]互不相同，我们可以令ri=lcm(b+1)/(b[i]+1)。如果有b[i]相等，而1/(b1+1)+1/(b2+1)+...+1/(bn+1)=1,那么就无解。
否则，可以随便找个比较大的数，做到ri互不相等。
