SRM 603 Div1 Med
用前k个小写字母组成长度为n(n<=1e9)的A串和B串，使得存在C，令A+C=C+B的AB有多少对。答案mod1e9+7。
Solution：
A+C=C+B，也就是说B前半段跟A后半段相等，A前半段跟B后半段相等。也就是说，任给一个A，它的n个循环都可以作为B。但是存在重复。
重复的情况必然是，存在L,A%L==0且任意[i,i+L](0<=i<A/L)都是相同子串。
且对于L的更小因子，也要去一下重。f[L]表示，L已经是最小不可分循环子串时，有多少种方案。那么ans=sum(F[L]*L+F[L-1]*(L-1)+...+F(1)*1)。

SRM 603 Div1 Hard
长度为n(n<=10^5)的两个整数序列AB，A[i]<=10^5，B[i]<=10^5。按照任意顺序重新排列A和B，然后对应位置的A[i],B[i]相加，设C[i]=A[i]+B[i]。
问可能出现次数最多的C[i]的出现次数以及这个C[i]的值。如果有多个次数最多的C[i]则输出最大的C[i]。
Solution：
如果A[i]+B[i]=C[i]，那么C[i]出现次数c就是min(a,b)其中ab分别是A[i]和B[i]的出现次数。
可以设置长为n的两个序列x,y，然后枚举次数c，如果cntA[i]>=c那么x[i]=1，同理如果cntB[i]>=c那么y[i]=1。
这样两个序列卷积相乘z=x*y，累加z[i]的和就是答案。
但是复杂度太高。可以看，每个序列出现次数超过10次的数不会超过10^4。这样可以先把这些数分别找出来处理，复杂度cnt1*cnt2。
其中cnt1和cnt2分别是两个序列里出现次数超过10次的数的个数。
然后对于小于10次，枚举次数[1,10)，然后把xy相乘，可以使用fft得到nlogn的复杂度。

SRM 620 Div1 Hard
给出一个n*n(n<=20)矩阵元素不超过1e9，要求选出一些元素满足每行选出了奇数个每列选出了奇数个，以及选出的数的乘积是完全平方数。问选的方案数mod 1e9+7。
Solution：
对于每行每列列出n*(n*n)的%2方程，得到2n个方程的%2方程组，求rank之后n*n-rank为自由变元数x，答案就是2^x。
对于完全平方数的条件，对于出现的每一个素数，只看power为奇数的那些元素，它们的和必须是%2==0。同样可以列出方程组。
对于有多少个素数需要考虑，可以去估计最坏情况：从小到大查看所有素数，考虑所有n*n个元素，并把它乘到最前的一个元素上并使它不超过1e9。
这样处理完n*n个元素之后，可以发现最坏情况下会有865个素数。所以是(865+20+20)*(20*20)。

SRM 636 Div1 Med
20*20的矩阵里面是"."和"#"。有r个兔子编号后按照顺序随机选"."然后蹲进去。蹲完之后每个兔子x选一个距离自己最近的另外的兔子设为f(x)，有tie就选行最小，
行一样选列最小。每个x和f(x)连边，构成无向图。问无向图中联通分量个数的期望是多少。
Solution：
首先图中如果有环则环长只能为2。因为如果是3，则必三者距离相等且三者行列序相等(which is 不可能)。
因为只有n条边，那么最后构成的图，联通分量的个数必然和长度为2的环的个数相等。因此我们枚举每一对满足u=f(v)&&v=f(u)的(u,v)算概率。

SRM 637 Div1 Easy
2N(N<=50)个数1-2N，分给两个人，每人N个。连续N轮出牌，两人出数大的得1分。
知道A的所有N个数，但是不知道他的出牌顺序；知道B的部分出牌顺序，不知道的部分给出-1。
问A的策略，使得得分的期望最大。
Solution：
首先保证，知道B出什么牌的round能把分数得到。因此根据B[i]，找出A中刚好大于它的数来跟它比。如果没有，就找还没出过的最小的数。
剩下的，B为-1的部分，因为是完全随机，因此A也完全随机。期望的计算方法遵循期望线性，对于未出现的每个数分别计算期望即可。

SRM 645 Div1 Med
平面上N<=50个点V1，每次从a,b,c三个点中选一个点，将V1所有点关于这个点对称。重复此操作任意次。问能否把V1变为V2。
Solution：
首先变换之后点的大小顺序不变，因此先排个序。然后偶数次变换之后org和tar点之间的delta必然形如2*i*(A - B)+2*j*(A - C)。
如果是奇数次变换，则先将所有点关于A/B/C变换一次，然后转化成偶数次的情况。

SRM 645 Div2 Hard
n<=10^12个人，m<=50个field。游戏进行k<=50轮，每轮每个人把自己的token放到一个field上，然后选一个随机的field删掉。所有选这个field的人出局。
问最优策略下，k轮之后至少一个人存活的概率多大。
Solution：
不要把鸡蛋放到一个篮子里。每次均分是最优策略。然后用个map暴力dp。由于每次只会加进来最多2个状态，所以总状态数是O(n)的。一切暴力即可。

SRM 656 Div1 Med
有多少1-n(n<=10^6)的排列满足当且仅当下标idx在给定数组pos(size<=2500)时，p[idx]<p[idx+1]。答案mod 1e9+7。
Solution：
将排列分段。考察以每个pos[i]+1开始的递减序列。假设长度分别为a,b,c(a+b+c=n)。那么利用容斥原理，答案应该是
ans=C(n,a)*C(n-a,b)*C(n-a-b,c)-C(n,a+b)*C(n-a-b,c)-C(n,b+c)*C(n-b-c,a)+C(n,a+b+c)。
把最外面的项相同的合并，把这一项提出来，可以得到n^2的式子。

SRM 657 Div1 Med
给定多项式P(x)=x^d[0]*(x-1)^d[1]*(x-2)^d[2]*...*(x-n+1)^d[n-1](n<=10000)。问，不管x取何值均能整除P(x)的最大正整数是多少。答案mod 1e9+7。
Solution：
设答案d=p1^a1*p2^a2*...*px^ax。对每个素数pi，需要知道ai最大是多少。我们只需考察x属于[0,pi)的情况，设x=x0,则x0+m*p与x0情况相同。
因此枚举x[0,pi)，得到的幂次加和。但是还有pi的多次幂的情况，因此需要递归求解。
比如x=0时，取出的项是(x-0),(x-p),...(x-p^2),(x-p^2-p)，那么根据x=0还是x=p,p^2的幂次是不一样的。因此需要再次枚举x'[0,pi)，
得到的和的max值加到之前的结果里。

SRM 657 Div2 Hard
求一个[0,10^9)之间的整数x，满足P(x)=a*x^2+b*x+c能被10^9整除。
Solution：
被10^9整除，则能被2^9和5^9整除。枚举[0,5^9)之间的数，找到一个代入P(x)之后mod5^9=0的x。然后枚举10^9/5^9=2^9项，找一个能被2^9整除的数即是答案。

SRM 664 Div1 Easy
两堆石子A,B(A,B<=10^9)。执行K(K<=2*10^9)次操作，每次从大的一堆石子中取石子double小的一堆。问K次操作后小的一堆石子是多少。
Solution：
如果A<=B,则A->2*A,否则，A->A-B=A-(S-A)=2*A-S(此时2*A > S)。因此可以看成每次都是把A乘2后％S。那么就计算(A*2^K)%S。之后取A和S-A较小的一堆即可。

SRM 677 Div1 Easy
把(a,b)变成(A,B)(a,b,A,B<=10^9)，每次可以把两个数乘以2可以给两个数都加1。问最少步数。
Solution：
A一定为2^x * a + 2^y1 + 2^y2 + ...的形式，B同理。因此对于a＝b的情况，找出x的最大值。对于a!=b的情况，找出(A-B)/(a-b)。
然后注意一个坑，后面y1<=x。因此从小到大枚举2的幂次，超过x的部分全部用＋1。

SRM 683 Div1 Med
n(n<=10^5)个数，每次选两个，从集合中删掉，再把gcd和lcm加进去。问最后这些数和最大是多少。
数字生成方式：给定start,cnt数组，for i=1-|start| : for j=0-|cnt|-1 : add start[i]+j*d[i]。
Solution：
最后必然是每个素数的幂都从小到大排列。直接对每个数分解质因数，然后暴力填进n个数里。(复杂度？)

SRM 686 Div1 Med(strling)

SRM 697 Div1 Easy
给一个长度为n(n<=50)的数组b,1<=b[i]<=10。问是否存在一个长度为n的数组a，满足a[i] >= 2且a[i]互不相同且对于每个a[i],
a[i]^b[i]能被T/a[i]整除，其中T=a[1]*a[2]*...*a[i-1]*a[i+1]*...*a[n]。
Solution:
对于某个素数p，假设p^ri | a[i],则需要满足ri * bi <= S-ri(S=r1+r2+...+rn),也就是(bi+1)*ri<=S，也就是ri<=S/(bi+1)。
n个不等式左右相加，得到S<=S/(b1+1)+...S/(bn+1)。也就是1/(b1+1)+1/(b2+1)+...+1/(bn+1)>=1。
还有条件a[i]必须互不相同。如果b[i]互不相同，我们可以令ri=lcm(b+1)/(b[i]+1)。如果有b[i]相等，而1/(b1+1)+1/(b2+1)+...+1/(bn+1)=1,那么就无解。
否则，可以随便找个比较大的数，做到ri互不相等。

SRM 704 Div1 Med
n(n<=50)个在[0,k)(k<=10^9)之间的数组成一个序列，给出q(q<=1000)个询问，问满足乘积mod k = q[i]的序列有多少种。
Solution：
首先设n个数的乘积是X，那么X % k == q[i]条件是，gcd(X,k)==gcd(q[i],k)。那么我们可以dp出n个数乘积和k的gcd为d的方案数num。
同时，由于q[i]必然是在[0,k)之间的，那么可以求出y属于[0,k)之间，gcd(y,k)=d的cnt。这样，由于对称性，每个y的方案数就应该为num/cnt。
对于num，由于10^9以内的最大合数为735134400，有1344个因子，因此dp的复杂度大约为50*1344*1344。
对于cnt，求法是，对于d[i],cnt=k/d[i]-(cnt for d[j]，其中d[j] % d[i] == 0)。
还有一个优化就是，我们每次转移的时候如果从d[a]->d[b]那么d[b] % d[a] == 0必然成立。
因此可以把所有d[a]的倍数d[b]找出来，且预处理出d[a]->d[b]的方案数。

SRM 707 Div1 Med
问通过每次+a/*b，把s变成t的最小步数。其中a,b,s,t<=1e18。
Solution:
((s+an*a)*b + a1*a)*b + ... +a0*a = t。
重写一下就是(t-s*b^n)/a = sigma_i(ai * b^i)。那么就只要从小到大枚举n，求出对应式子右边的数的b进制表示法各位上的和。找一个最小的即可。
小trick：判断是否溢出：a*b/a=b。

SRM 711 Div1 Med
给一个长度为n(n<=50)的数组a，a[i]表示p[i]在X中的幂(a[i]<=50)。其中p[i]为第i大的素数。那么X=p[1]^a[1]+p[2]^a[2]+...+p[n]^a[n]。
问乘积为X的大于1的正整数序列方案数。
Solution:
由于序列长度最长为50*50，那么枚举序列长度，然后假设长度为L，就把每种prime放到序列中去。
dp[L]=C[L-1+a[1]][L-1]*C[L-1+a[2]][L-1]*...*C[L-1+a[n]][L-1]。
然后注意去掉有1的情况，就是dp[L]要减去C[L][L-1]*dp[L-1]+...+C[L][1]*dp[1]。

SRM 713 Div1 Easy
满足a^b=c^d且1<=a,b,c,d<=n<=10^9的方案数。
Solution:
a^b=c^d，底数只保留不可开方的数，那么必然可以写成a^x1b1=a^x2b2。其中a是一些素数幂的乘积。
那么a<=sqrt(10^9)时，可以枚举a,x1(<=30),x2(<=30)，然后方案数就是min(n/(lcm(x1,x2)/x1), n/(lcm(x1,x2)/x2))。
如果a>sqrt(10^9)，这意味着x1必须=x2。那么b1=b2。方案数就是n*n。
排除掉这一部分之后，在枚举的时候只要保证x1 != x2即可。
还有一点:由于a是一个不可以开方的底数，那么枚举的时候要保证它不是谁的幂。需要用一个set把枚举过的数及其power存起来以备以后检查。

SRM 733 Div1 Med
n个点的无向完全图，顶点编号1->n。问包含给定边集E的生成树有多少种。
Solution：
如果给定边集有环，则答案为0。
否则E可以分成一些集合，这些集合和在E之外的独立点共同构成k个components。
按照Cayley's formula的推导过程:
(https://haomaoer.wordpress.com/2016/12/02/caley%E5%85%AC%E5%BC%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AF%81%E6%98%8E/)
从n个点中每次选一个往其余k-1个集合的根连边，这样就是n*(k-1)*...*n*1。除以选边顺序(k-1)!。
再考虑一棵最终的生成树有n个根的情况所以除以n。答案就是n^(k-2)。
对于最开始的k个集合Sk，根的选择有|Sk|种。所以最终答案就是n^(k-2)*|S1|*...*|Sk|。

SRM 734 Div1 Easy
找到互素的pair(a,b)满足a^2+b^2<=r^2(r<=10^6)。
Solution：
枚举a，然后分解a的时候打表常优。
table[x]表示要分解x，下一个最小的素因子是多少。这个可以筛法求出。

SRM 735 Div1 Med
求[0,m)(m<=10^5)内有多少x满足(x^2%m=x)。如果x不超过500个则输出所有，否则循环取奇数位置直到个数不超过500个。(题目保证x个数不超过10^5)。
Solution：
x^2%m=x -> x*(x-1)%m=0。因为gcd(x,x-1)=1，因此枚举m的因子a满足gcd(a,m/a)=1，然后求a*k1+m/a*k2=1的解，其中x=a*k1,x-1=m/a*k2。
因为ax+by=gcd(a,b)的通解x=x0+b/gcd(a,b)*k，因此a*k1+m/a*k2=1的解满足x1=x2+m/a*k。因此[0,m/a)之间只有唯一解。暴力求出即可。

TCO18 R2C Hard
给定m(m<=10^15)，问有多少0<=x<m满足x^2 == x (% m)。
Solution:
x^2-x==0(% m) -> x*(x-1)==0(% m)。
也就是说x和x-1必然互素。
对m分解质因数设为a,b(=m/a)。求解ax'+by'=1，且使得0<=x'<=b。
那么得到x=a*x'。

TCO18 R3B Med(概率&期望)
有20个同学，每个人在每一秒有p[i]的概率离开。问人全部走掉的时间t的期望。
Solution1(DP):
记忆化搜。
dp[i,j,k]表示当前留下的人的状态是i，枚举到第j个人(对状态i从0到n-1枚举，以便处理所有子集)，本次枚举子集(到n时结束)是否有人离开。
Solution2(Math):
对每一秒单独考虑贡献。
E = ∑(t){1 - π(i)[1 - (1 - p[i]) ^ t]}
展开之后，大概就是类似容斥原理的式子。

SRM 742 Div1 Easy
初始化有个0号数值为1。现在有两种操作，在生产第i号产品时，可以选0->i-1号产品中选两个(假如值为x和y)，做两种操作。
0号操作是x+y，1号操作是1/(1/x + 1/y)。
现在给出n(n<=10^18)，要求使用不超过1000次操作凑出n/10^9。给出操作序列。
Solution：
把n/10^9之后，得到整数部分和小数部分。分别使用2的幂去凑出它的整数部分和小数部分的二进制表示。
整数部分可以使用0号操作，小数部分可以使用1号操作。

SRM 751 Div1 Med
给出g和h和m，已知长度为n(n<=10^6)的y序列满足存在一个长度相同的x序列使得g^x=y(mod m)，现在要把g替换为h，求所得y'序列的各项和。
Solution：
实际上是要找到替换h=g^z(mod m)中的z。具体方法求离散对数(?)。

SRM 757 Div1 Hard
给出n(n<=50)种颜色，每种颜色a[i](a[i]<=50)个球。每次随机选出两个球，颜色不确定。把一个球的颜色涂成另外一个球的颜色再按照原顺序放回。
问最后全部涂成同色的期望次数。
Solution：
dp的话不能记下所有颜色的个数，又不能只记颜色，因此我们考虑最后unify之后的颜色。只需要记下是这种颜色和不是这种颜色各有多少个。
设总数有s个，dp[i]表示当前颜色i个，最终要全部涂成当前颜色的期望步数。
因此dp[i]=i*(s-i)/s*(s-1)*dp[i-1]+i*(s-i)/s*(s-1)*dp[i+1]+i/s。
最后的i/s是因为从i个变为s个每次+1和-1个的概率相等，因此看成random walk，到s个的期望就应该是i/s(???)。
整理得dp[i+1]-dp[i]=dp[i]-dp[i-1]-(s-1)/(s-i)。由于dp[s]=dp[0]=0,因此根据dp[s]求出dp[1]=(s-1)*(s-1)/s。
然后代回去依次求得dp[i]。答案就是sum{dp[a[i]]}。

SRM 760 Div1 Med
坐标平面上(|x|<=n,|y|<=n)(n<=5000000)范围内，除原点每个整点处有一个mice，(0,0)有一个cat。问cat按照某个射线方向奔出，要刚好吃到c个mice。
问不同射线方案数。
Solution:
假设有一条斜线它的斜率是k=a/b(a<=b)，那么如果n/b>=c&&n/b<c+1，那么我们只要累加phi(b)也就是小于b且与b互素的数就可以。
对于phi(b)=b*(1-1/p1)...(1-1/px)其中p1,...,px是b的素因子。
而b的范围其实是ceil(n/(c+1))-floor(n/c)。理解起来就是把n刚好分成c组，每组个数这个是b的上届；分成c+1组，每组个数是b的下届。
求出答案之后×8。如果n==c，则+=8。

SRM 772 Div1 Med
给出n(n<=10^5)个整点，定义两点间距离为曼哈顿距离。现选出点集S，使得inside(S)-outside(S)<=k。问S中最多多少个点。
其中inside(S)是集合内的点两两之间距离和，outside(S)是集合外的点两两之间距离和。
Solution：
算一下会发现，设f(x)为点x到其他所有点距离和。那么最后的cost+tot=sigma(f(x))。其中tot为所有点的两两距离和，sigma(f(x))为集合内点的f(x)和。
因此按照f(x)排序，从小到大选即可。
求两两距离和时，可以按照x排序扫一遍；再按照y排序，扫一遍。x结果和y结果加和。
