SRM 604 Div1 Med
50个顶点的一棵树，有一些节点有狐狸。现在每个狐狸走到一个位置去，使得所有有狐狸的节点联通成一棵子树且所有狐狸走过的距离之和最小。
Solution:
最后的根必为其中一个顶点。枚举根dp，dp[cur][en][fox]表示第cur个顶点，枚举到它的第en条边，往里塞fox个狐狸的最小走过距离。
有个trick是左儿子右兄弟表示法：
dp[cur][en][fox] = dp[nxt][0][i] + dp[cur][en+1][fox-i]。
也就是每一步分裂出当前节点的儿子nxt+i个狐狸，和当前节点剩余儿子+(fox-i)个狐狸。

SRM 605 Div1 Med
1-2N(N<=50)个数要等分成两个集合，使得|A[i]-B[i]|>=k(k<=10)。问方案数。
Solution:
按照从小到大的顺序扫一遍，对于第i个数，可以放在A或者B。凡是i-K之前的都可以和它在同一个集合，而不用在乎是哪个具体的数字。
但是i-(k-1),...,i-1则要考虑状态压缩表示出每个数是在A还是B。
dp[i,j,s]表示A有i个数，B有j个数，且[i+j-(k-1),i+j-1]有子集s在A中的方案数。

SRM 605 Div1 Hard
给出N(N<=200)个数的一个排列P，每次可以选一段连续的子串把所有数换成子串中最大数。最多执行K(K<=200)次。问最终序列不同的方案数mod 1e^9+7。
Solution：
有几个观察：
数字的顺序不会改变；相同数字重复的段数不会出现>1次；如果P[i]最终要出现在j这个位置上，那么[i,j]之间的数字P[k]必须全部<=P[i]。
我们从小到大看最终序列中的数字S[i]，如果S[i]出现超过1次，那么操作次数+1；如果出现次数=1次，那么S[i]=P[i]则不需要加操作次数，否则+1。
这样，最少操作次数实际上是确定的。
因此可以dp。dp[i,j,k]表示P的前i个数去覆盖S的前j个数，还能用k次操作的方案数。这样一来转移O(n)。
如果要消去这一层，要一个一个地转移，多加一维c表示是否已经累加P[i]产生的操作次数(0or1)。然后记忆化搜。

SRM 607 Div1 Hard
(0,0)和((n+1)d,0)处有两个点PQ，中间每隔d(i*d,0)处有个半径为r的圆。要用一根绷紧的线连接PQ，满足要跟中间的n个圆相碰或者缠绕。
把所有可能方案按照长度从小到大排序，问排在第K位的长度为多少。(d,r<=10^9,n<=50,K<=10^18)。
Solution：
二分长度然后求方案数是否<=K。可以发现有四种不同线段，连接相邻两圆顶端的A；连接相邻两圆顶和底的B；绕圈的半圆R；连接P/Q和0/(n-1)圆的e。
由于e出现且仅出现两次，所以dp时先不看。只考虑中间长度，假设当前二分到长度L，dp[i,a,b,c]表示当前在第i个圆，有a个A，b个B和c个R的方案数。
当前绕线前进方向由c奇偶决定。要求a*A+b*B+c*R=L。其中ab可以进一步合并成w，最后乘上comb(w,a)即可。
这样由于对于一个w，comb(w,a)求和是2^w级别的，因此w不会超过64。对于c，虽然很大，可以忽略所有的整圆，这样两个(A+B)之间最多有一个R。
最后把多出来的整圆插到w个(A+B)之间即可，数量是comb(w+1+c',w+1)。其中c'是整圆个数。

SRM 610 Div1 Med
原先有F(F<=5000)燃料，有n(n<=50)个任务。每个任务消耗d[i],加油r[i]。问所能完成任务个数最大多少。
Solution：
排序然后dp。
按照r从大到小排序。
为什么呢。
如果a->b,那么F-d(a)+r(a)>=d(b)；如果b->a,那么F-d(b)+r(b)>=d(a)。
所以r(a)>r(b)时，前者较容易满足；反之后者较容易满足。

SRM 610 Div1 Hard
n*m(n<=10^6,m<=10^6)的矩阵，一共有k(k<=1000)天，选择起始坐标之后，每天可以移动到一个新的坐标，满足|xi-x(i+1)|<=dxi && |yi-y(i+1)|<=dyi。
每天会在(exi, eyi)处发现一个金币，则如果当天位于坐标(xi,yi)那么获得收益n+m-|exi-xi|-|eyi-yi|。
问如何选择每天坐标，使得k天总收益最大。
Solution：
首先注意到x和y是互相独立的。
对于某一维，从朴素dp开始想起。f(i,x)表示第i天在坐标x处的最大收益。那么f(i,x)=max{f(i+1, y)} + n - |x-ei|。
复杂度太高。这里有一种神奇的解dp的方法。画函数图像！！！
f(i,x)是一个concave函数，max{f(i,x)}也是一个concave函数，不过以最高点为对称轴向两边各expand了dxi/dyi。
当我们加上n-|x-ei|时，由于这也是一个concave函数且concave函数的和也是concave函数，所以得到的还是concave函数。
所以我们可以迭代k步，每次是expand之后add。由于expand之后x会超出[0,n]，所以我们要cut一下，也就是只保留[0,n](包括0和n这两点)。
每次迭代维护一条polyline，line上最多有k个节点，原先不存在的点要interpolate出来。每次最多增加1/2。

SRM 613 Div1 Med
给出[low, high]的一个区间，其中high-low<=10^5。用这个区间内的数字构造一个长度为n(n<=10^9)的数列，满足数列的gcd=k(k<=10^9)。
问方案数。
Solution：
实际上是求[low/k, high/k]中gcd为1的数列方案数。
dp[i]表示gcd=i的方案数，dp[i]=(dp[i]-dp[2*i]-...-dp[i*j]) (i*j<=10^5+1)。
如果i*j>10^5+1，那么整个区间必须全部选这一个数(区间长度不超过10^5+1)。
那么可以枚举区间内每个数字[low/k/i, high/k/i]，在dp[i]里减去1即可。

SRM 613 Div1 Hard
给一个n(n<=50)*m(m<=200)的矩阵，给出n个left和n个right，在矩阵中填1，需要满足：
1. 每一行中，左边left[i]列有且只有1个1，右边right[i]列有且只有1个1。
2. 每一列中，最多有1个1。
问方案数mod 1e9+7。
Solution：
从左到右check每一列，记录有多少需要end的left和多少已经start的right。因此每一列可以有4种选择：
1. 不放。
2. 放在非left也非right的格子里。
3. 放在left的格子里。
4. 放在right的格子里。
一个trick是，当我选择满足left的时候，我只是记下选了多少col用来满足left而不去分配给具体的left[i]；
而是在等到碰到left[i]的end列的时候才乘上组合数去分配。
因此dp[i,j,k]表示到第i列，选了j列去满足left，有k个right已经start且需要去满足的方案数。

SRM 614 Div1 Med
n(n<=50)个环，每个环不超过10^6个点。然后环之间用边相连(toVertex[i]->fromVertex[i+1])。用k(k<=10^9)种颜色染色。
给出fromVertex数组和toVertex数组，要求toVertex[i]和fromVertex[i+1]同色。且环上相邻两点不同色。问方案数。
Solution：
dp。首先考虑单个环上的情况。转成链来看。dp[n,0]表示n个顶点，两头同色的方案数，dp[n,1]表示n个顶点两头不同色的方案数。
然后对于cycle of cycle，可以沿用这个思想。枚举toVertex[n-1]也就是fromVertex[0]的颜色，dp出toVertex[0]也就是fromVertex[1]的颜色。
dp方法是，把环0在fromVertex[0]和toVertex[0]处拆开，拆成上下两半，设为top和bottom。
然后可以使用dp[top][0]/dp[top][1]/dp[bottom][0]/dp[bottom][1]的结果。

SRM 618 Div1 Med
给出含有n(n<=5000)个字母的字母表，拼成一个串。相邻字符不相等，且串中不出现xyxy形式的子序列。问最长的合法串的方案数。
Solution：
首先长度最长是2n-1，也就是所有字符出现一遍之后再倒序出现一遍。
有三种形式：
aSaS'a / SS'(S'为S的倒序) / abc...xSxS'x...cba。
因此dp时候可以枚举是两端相同，还是三个相同字母夹两段。dp[n]=dp[n-1]+{dp[x]*dp[n-1-x]}。

SRM 623 Div1 Med
一个人从(0,0)出发，可以在x轴上以每秒1的速度移动。n(n<=500000)个水果从天而降，每秒掉1。掉到x轴上时候人可以跑过去接住它。
问人最多接到多少水果。
Solution：
连续两个接到的水果要满足y1-y2>=|x1-x2|。
因此：y1-y2>=max(x1-x2, x2-x1) ==> y1-y2>=x1-x2 & y1-y2>=x2-x1 ==> y1-x1>=y2-x2 & y1+x1>=y2+x2。
因此坐标变换(y,x)==>(y-x,y+x)。按照这个pair排序，对y+x求LIS。
需要注意的是，因为一开始从(0,0)出发，因此每个接到的水果都必须要满足y>=|x|。

SRM 629 Div1 Med
有一些糖，有n(n<=1000)种形状，n种味道。每颗糖有一种形状一种味道，只能看出形状不能尝味道。
每一种形状对应有exactly两种味道，每一种味道有exactly两种形状。
现在告诉type1,num1,type2,num2，形状为i味道为type1[i]的糖有num1[i]颗，形状为i味道为type2[i]的糖有num2[i]颗。
现在要买齐n种味道，至少买多少颗糖。
Solution：
因为只能看到形状，因此以形状划分阶段性。对于某一种形状i，两种口味分别有n1,n2颗(n1<n2)。
要么不买；要么买min(n1,n2)+1来cover第二种口味；要么买max(n1,n2)+1来cover两种口味。
然后根据口味把形状一个一个串联起来形成环，对于每一个环进行dp。假设每个形状有左右两个口味。
dp[i,a,b]表示到了环上第i个形状，环上第一个左边(也就是最后一个右边)的口味是否被cover，第i个形状右边的口味是否被cover的最少糖果数。

SRM 637 Div1 Med
2×1000的格子，每个格子为B或者W。开始时，存在一条从左到右的W的通路。现在AB轮流，每人选一个W涂成B。最后一个断掉所有从左到右W的通路的人lose。
问先手必胜必败。
Solution：
真正有意义的需要考虑的pattern是：
WWW...W   或者  WWW...B
BWW...B        BWW...W
因此dp[cnt,l,r]表示中间WW部分长度为cnt，左右边界为l和r的nim结果。
然后把每一段xor起来即可。

SRM 638 Div1 Med
给出n(n<=50)个数的数组A，如果A[i]+A[j]<=maxSum就可以swap。问最后可能的排序有几种。
Solution：
分治dp。每次找当前最大值A[x]，然后只要A[i]+A[x]<=maxSum那么A[i]就可以任意放置到任意地方。因此假设满足的i有m个，那么就是ans*=m!。
剩下的数字将永远不可能越过A[x]，因此分配到A[x]的左右两侧分别递归求解。

SRM 644 Div1 Med
N=10^15个人，进行K<=6轮比赛。每轮将现有人数分成R个room，每个room人数不少于2。每个room一人胜出，进行下一轮room划分和比赛。最终K轮之后至少1人胜出。
问room划分总方案数。
Solution:
给N个叶节点，组成一棵K层的树，使得除了叶节点以外每个节点儿子数>=2。问构造方案数。
由于6比较小，6!又不可能。。。考虑2^6的算法。。。
假设我们从左到右把叶子节点加进来，那么当前刚加入的叶子节点和总的root之间的这条路径以左的非叶节点必然已经满足儿子数>=2的条件了。
那么就看这条路径上的节点的状态。用0表示儿子数为1，用1表示儿子数>=2。就可以得到2^6的状态了。
转移的时候，从最低位到最高位，第一个0以及比它低位的所有1都可以作为新的分叉点。
比如10111可以转移到10111, 10110, 10100, 11000。
于是我们得到2^6 * 2^6的转移矩阵。之后用矩阵快速幂求即可。
需要注意的是，因为最终可能不止一人胜出。于是要加一个虚拟根节点变成k + 1层。
而取解的时候变成同时取出res[(1<<K) - 1][0] + res[(1<<(K + 1)) - 1][0]即可。

SRM 647 Div1 Med
n<=500个机器人，价钱cost油量cap，从原点出发向右运动，每秒钟耗费1unit油。
每个时刻每个机器人可以选择反向回去，保证油量能返回原点的情况下剩余油量送给下一个机器人。
有总钱数B<=10000，买一些机器人，要使得最后剩下的机器人走得最远。问有多远。
Solution：
假设已经买定一个set的机器人，如何最远？首先一定是cap小的把油给cap大的。设capA < capB,t时刻后返回，那么送出的油量是min(capA-2t, t)。
画图分析，极值点取在capA/3处。那么这两个可以合并成capB + capA/3。多个的以此类推。至于买哪些，直接dp即可。

SRM 647 Div2 Hard
给10^9个building设定高度，满足building[1]=0，相邻两个building高度delta<=k(k<=10^9)，所有高度非负数。
且满足，给定x(size<=500)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
不能枚举最大高度是哪个，但是可以二分最大高度是多少。对于一对(x,t)，二分的最大高度是h，那么h和x的距离d>=(h-t-1)/k。
因此有非法区间[max(1,x-d),min(x+d,n)]。取所有非法区间的并集，看补集是否为空。

SRM 652 Div1 Med
n<=1000个点，m<=2500条边的有向图。每条边上有个cost。A想尽量快地从0到n－1，B有k<=1000个token，想尽量阻止A到达n-1，如果不能，就让A尽量晚到。
每次A会告诉B她要走的边，B可以选择使用token改变A要走的边，也可以选择不使用。问双方都最优策略，A多久到n－1。
Solution：
dp[i,j]表示在i节点，已经使用了j张token要到达n-1所要花费的最小cost。
那么在i节点，A要选择的是所有临接节点里面dp[k,j]最小的，而B要选择的是所有dp[k,j+1]里面最大的。然后从n节点倒着dp回0节点即可。
几个技巧：
1）可以以k划分阶段，滚动优化。
2）每次可以预处理出B的选择，以便在i+1时可以直接用。

SRM 655 Div1 Med
5000个位置填[0,9]的数字，N=5个问题。每个数字对应一个mask，表示这个数字会出现在第几个问题里。
对于每个问题，按顺序读会出现的数字之后会组成一个十进制数，问所有N个问题得到的十进制数mod9都为0的方案数。
Solution:
注意到每个数字只会影响mask所包含这几个问题的结果，那么可以按照这个mask把数字归类，统计这一类中各位数字mod9的结果，先dp预处理出来。
然后把每个mask对应的结果放到总的结果里。
然后这个实现的时候还有个点，添加每个mask对应结果的时候，按照mask从小到大正常地状压dp就可以了。

SRM 656 Div2 Hard
有多少1-n(n<=200)的排列满足当且仅当下标idx在给定数组pos(size<=200)时，p[idx]<p[idx+1]。答案mod 1e9+7。
Solution:考察折线的每个极小值点。用dp[i,j]表示[i,j]的方案数，那么j-i+1个数的最小值必然是放在极小值。
然后可以分成两段。dp[i,j]=dp[i,k-1]*dp[k+1,j]*C(j-i+1,k-i)。

SRM 658 Div1 Med
有n<=20个敌军，每人血量<=60。每次可以开一枪，选一个人掉血9，一个人6，一个人3。三者不能是同一个人。问杀死所有人最少开多少枪。
Solution：
二分开枪数m。dp[i,n9,n3]表示前i个SCV用了n9个9和n3个3消耗的最少的1的个数。枚举时满足条件对一个敌军，n1+n3+n9<=m。

SRM 660 Div1 Med
n<=50个人，每个人有个讨厌的人。随机地邀请这些人，如果他讨厌的人没来他就来。问来人数的期望。
Solution：
分情况讨论。
先看链。只跟长度有关。枚举去掉哪个点，dp。
看环。去掉一个点，转成链。
看带链的环。去掉链上的点好说；去掉
环上的点会变成“Y”字形。设三条arm分别为a,b,c，那么根据独立性，这个“Y"字形的答案就是f(a + c) + f(b + c) - f(c)。
综上所述，对于一个点，如果是在环上，求环的期望，又因为环上每个点的对称性，除以环长得出每个点的概率；
如果在链上，求它距离环的距离，设为d，连接的环长为r，根据独立性，那么答案就是f[d][r] - f[d - 1][r]。
找环的时候这个“追击”的方法竟然是floyd发明的？！
确定连接环的链长，方法是，找到环的时候两者相遇在环上的位置是p,那么从p和链的起始s，同时前进，相遇的位置即为环开始的地方，走过的长度即为连接环的链长。

SRM 661 Div1 Med
n<=10^12个点，每个点k<=10^12种可涂的颜色。每个点i可以向j(j < i)连边，问图的不同方案数mod m(m<=10^6)。
Solution：
直接dp。m较小，按照mod值分类。

SRM 663 Div2 Hard
n(n<=16 and will be power of 2)个人比赛，每两个人一组，胜者继续。问最后每个人分别有多少种方案数可以赢。
Solution：
dp[i,j]表示集合i包含的人当中j胜出的方案数。

SRM 664 Div1 Med
n(n<=10^6)个顶点的一棵树，对每个顶点攻击一次。攻击之后保留这个点的概率是1/(i+1)，i/(i+1)的概率这个点以及联通它的边消失。
设攻击完之后剩余联通分量顶点个数分别为n1,n2...nk。求n1^2+n2^2+...+nk^2的期望*N!之后mod 1e9+7。
Solution：
(a+b)^2=a^2+b^2+a*b+b*a。实际是两两相乘。
那么nk^2实际上可以转化成联通分量里联通的顶点pair(u, v)的对数。这样就可以对每一个pair计数概率。dp[u]表示以u为根的子树中，含u的pair出现的概率。
generate法则保证儿子的标号大于父亲的标号，因此从大到小枚举即可。

SRM 666 Div1 Med
对于n(n<=4000)个数的排列，按照排列各个位置上数字去放东西。比如(p1, p2, p3)=(1,3,2)，那么先在1上放一个，再在3上放一个，最后在2上放一个。
每次放的时候给结果乘以一个(n-x)其中x为当前放的位置的左右两边已经有的东西的个数。然后求所有排列的这个值的和。
Solution：
dp[i]表示前i个数的排列的和，那么第i + 1个数可以放在两端，也可以放在中间。

SRM 669 Div1 Med
n(n<=200)个点的完全图，每条边边权是[1,l(l<=200)]。对于l^(n*(n-1)/2)种图中的每一个，count线型生成树的个数，然后对所有图加和。问和是多少。
Solution：
dp[i,j]表示前i条边，线型MST上最大色为j时的方案数。这里要枚举第一条最大的边是哪一条(比如为k)，
然后将这i个点分成了两个部分，前k-1条边最大色为j - 1，后面i-k条边上的最大色则为j。然后跨两部分的边的可选色为l-j+1，则转移为:
dp[i,j]=dp[k,j-1]*dp[i-k,j]*((l-j+1)^(k*(i-k)-1))。

SRM 672 Div1 Med
求n(n<=2000)个点(无自环无重边无向图)的近欧拉图有多少种，结果mod 1e9+7。近欧拉图包括欧拉图＋加一条边/减一条边能变成欧拉图的图。
Solution：
由近欧拉图得到欧拉图，图中有不超过一对奇度点，连接or删掉这对点之间的边即可。因此每一个欧拉图对应n(n-1)/2+1个近欧拉图。
设n个点欧拉图方案数为E。欧拉图定义为：每个点degree为偶数且联通。那么我们可以求出degree全为偶数的图的方案数(设为D)再减掉不联通的那些(设为R)。
对于D，每一个n-1个顶点的图都对应一个n顶点的degree全偶的图(第n个点补上缺掉的degree就行)，因此方案数2^((n-1)*(n-2)/2)。
对于R，如果不联通必然包含多个联通分量。假设1所在的分量有k个点，那么就有C(n-1,k-1)*(Dk-Rk)*Dn-k。因此E=D-R，求出即可。

SRM 673 Div1 Med
求1-n(n<=100)的每个排列所对应的Cartesian树中得分<=s(s<=100)的方案数。
Cartesian树定义：小根堆二叉树，中序遍历此树能得到对应排列。
得分计算方法：对于树中有两个儿子的顶点，找出两个儿子在原排列中的对应下标差，sum up所有这样的值。
Solution：
dp[i,j]表示i个数和为j的方案数。转移的时候枚举左边根下标idx1和s1，右边根下标idx2和s2。
那么可以预处理出sum[s1+abs(k-idx1)]和sum[s2+abs(k-idx2)]，其中k为i个数中的根的下标(即i个数中的最小值)。

SRM 675 Div2 Hard
问能否构造出n(n<=50)个顶点和exactly有s(s<=1000)条长度为2的path的树。
Solution：
直接dp。dp[i,j,k]表示i个点有j个叶子长度为2的path条数为k是否可能。

SRM 677 Div1 Med(🌲dp)

SRM 684 Div1 Med
n(n<=50000)个数的sequence，每个数在1到k(k<=50000)范围内。问有多少符合条件的序列。条件：对i,a[i]<=a[i+1] or a[i] % a[i+1] != 0。
Solution：容斥思想。good(n)=k^n-bad(n)。
bad(n)=bad(n-1)*k + good(n-2)*seq(2)。其中seq(2)是a[i]%a[i+1]=0的pair。
然而，当我们把pair加到末尾的时候可能会导致good(n-2)中的最后一个和加进来的第一个数组成bad pair，因此要-good(n-3)*seq(3)。
这样只要一直容斥就可以了。
另外seq的长度因为是指数增长，因此不会超过log2(k)。对于seq直接dp计数即可。

SRM 686 Div2 Hard
n(n<=100)个"("和")"的括号序列，问不同的非空合法括号序列有多少种。
Solution：
dp[i,j]表示前i个位置多余j个"("的序列方案数。那么枚举下一个的时候，关键不是位置，而是是"("还是")"。因此就枚举是"("还是")"，
相应地选择第一个出现的位置转移即可。

SRM 690 Div1 Med
n(n<=10^5)个顶点的无向🌳，给每条边加个方向得到一个有向图。对于这个有向图求出有多少unordered pair(x,y)使得x->y有一条路径。
求所有2^(n-1)这样的有向图的unordered pair和。
Solution：
每条长度为k的路径贡献2^(n-1-k)=2^(n-1) / 2^k。那么dp路径，每次加一条边就乘一次2^(-1)。

SRM 690 Div2 Hard
在2*n(n<=1000)的格子上安排0-2*n-1的🐺站位。问有多少种满足条件的方案。
条件：1）每一行至少有一个编号>=k的🐺；2）按顺序写出每一列的编号较大值和每一行编号最大值得到n+2的序列，序列不同则为不同方案。
Solution：
首先关注行的最大值可以取多少。假设和2n-1放在同一行的数是[2n-1, m]，而第一个和2n-m中的某一个数放在同一列的是m-1，那么两行的最大值的不同组合
是2*(2n-m-1)(特别地，m<=k的时候只能取到2*(2n-k-1))。剩下的就是要求列的较大值的组合情况。可以直接dp。
dp[i,j]表示当前要放1-i的数字，而和2n-1在同一行的位置还有j个，列的不同较大值组合的方案数。那么对于i，可以把它塞到和[i+1, 2n-1]同一列，
也可以让它新开一列，成为某一列的较大值。最后列的结果乘上n!再乘上行的最大值的方案数即可。

SRM 693 Div1 Easy
n(n<=100)个顶点，对于每个i,i+1有一条权值为w1[i]的边，对于每个i,i+2有一条权值为w2[i]的边。问从图中删掉权值和最大的边，使得剩下的图为
2-edge connected，则剩下的边权值总和最小多少。
2-edge connected定义：任意一对顶点之间至少有两条不相交的路径。
Solution：
最后结果应该是一些环相互连接。如果有6个点，那么最后会是类似于0-1-2-0+2-4-5-3-2这样。设每个点有三种状态，即作为环的起点，终点和中间节点。
那么dp[i,j]就表示第i个点状态为j时候的最小边权和。之后转移。

SRM 694 Div1 Med
n(n<=1000)个人，m(m<=20)个问题，mat[i,j]=['A','Z']。问能把所有人区分开来的问题集合有多少个。
Solution：
预处理出任意两个人的答案相同的问题集合，则这个问题集合以及这个集合的子集是不可以的。状压dp从大到小推。

SRM 696 Div1 Easy
50个点的图，有m(m<=20)条无向边。要给所有点涂色，每次涂色花费是所有两端点都已被涂的边条数和。问最小代价。
Solution：
状压dp。dp[i]表示边集i被选进来的代价。枚举去掉某一条边的某个顶点，则去掉这个顶点的所有临接边的边集j，由dp[i^j]转移到dp[i]。

SRM 696 Div2 Hard
n(n<=20)个顶点个无向图，给出边的邻接矩阵，最多m(m<=20)组关系缺失。问2^m种不同的图，各自求最大团之后加和是多少。
Solution：
枚举每个顶点集合，求出使这个顶点集合x为最大团所必要的缺失边集合s，则更新dp[s]=max(dp[s],x)。
之后枚举缺失边i得到s的超集(s|(1<<i))，更新dp[s|(1<<i)]=max(dp[s|(1<<i)],dp[s])。

SRM 697 Div2 Hard
n(n<=1000)个选手参加2^m(m<=30)天比赛，每个选手有个a[i](0<=a[i]<2^m)能力值，第j天比赛时，把所有人的a[i]和j异或，按照从小到大排序。
每个人得分排名的平方。求每个人2^m天得分总和mod 1e9+7之后的和。
Solution:
对每个人算出排名第x的方案数。dp[b,r]表示在考察a[i]的第b位，排名第r位的方案数。然后枚举第b位是0/1转移。

SRM 698 Div2 Hard 🌲🌳🌴
n(n<=50)个点的一颗无向树，每个顶点有个权值。问每一棵子树上所有顶点权值求or之后得到的值的和是多少。
Solution：
拆位＋求补集。对于每一位，求出or之后含这一位的子树有多少。可以用补集，即求出or之后不含这一位的子树有多少。
dp[b,i]表示经过顶点i的，or的结果不含第b位的
子树总数。

SRM 701 Div1 Med
长度为n(n<=50)的string，对于每个0<i<2^n，从小到大扫i的每一位b，如果b是1的话就把s的最后b+1个字符翻转，最终扫完得到一个t。对于所有的t的集合，
找到字典序第k小的string。
Solution：
对于每一位从a到z枚举，然后dp出与当前前缀match的string方案数。注意到这个集合生成方式实际上就是，从0到n-1地枚举s的每一位，
选择把这一位从外往里地加入到t的两侧。比如t的前缀为i，后缀为j，那么s的第i+j+1个字符就可以加到前面的第i+1个和倒数的第j+1个。
因此dp[i,j]表示用了s的前i个字符，其中前缀长度为j的方案数。那么第i+1个字符可以放到j+1或者n-(i-j)个位置，但是要注意与前面枚举的前缀match。

SRM 702 Div1 Med
问长度为n(n<=150)的string，good的子序列排第k大的是谁。good定义：()或者(SSS),其中S为good string。
Solution：
首先dp出来长度为x的good string方案数，发现总数并不多(total 9526 when n <= 150)。然后暴力生成暴力check是否匹配即可。

SRM 703 Div1 Med
x轴上n(n<=50)个点(d[i],0)，y轴上方n个点(x[i],y[i])。现在要把x轴上的n个点与y轴上方n个点做个匹配且连一条线段，要求这些线段两两不相交。
求匹配的方案数mod1e9+7。
Solution：
dp。首先把x轴上点按照d[i]从小到大排序，然后y轴上方的点按照y从大到小排序。
dp[l,r,v]表示x轴上[l,r]的点与y轴上方的点集v匹配合法方案数。每次枚举i∈[l,r]与v中y最大的点连线，则把平面分成左右两部分，可以分治求解。
虽然复杂度较高，但是据说状态数大部分可以砍掉。具体见代码(。

SRM 704 Div2 Hard
长度为n(n<=10^9)的序列，每个数[0,k)(k<=100)。问多少序列满足乘积mod k = v。结果mod 1e9+7。
Solution：
快速矩阵幂。构造一个矩阵满足a[i][j]是前面mod k = i时，再乘一个数转移到j的方案数。

SRM 603 Div1 Med
问有多少合法的串对(A,B)满足，|A|=|B|=n(n<=10^9)且AB中的字符均属于前k个小写字母且存在一个C满足A+C=C+B。
Solution：
首先满足条件的A和B必然是形如(x+y,y+x)的形式，即B是A的一个rotation。那么看一个A会有多少个不同的rotation，这取决于A中最长的循环节长度。
对于循环节长度为d的A，方案数有f[d]*d。那么可以dp这个f[d]，但是要注意减掉d' < d && d' | d的f[d']。最终求出g[d]，即以d为最长循环节的串的方案数。

SRM 604 Div1 Med
n(n<=50)个顶点的一棵树，某些顶点里有狐狸。这些狐狸要移动到一个联通的子树里面，子树中的每个节点有一个狐狸。问所有狐狸移动的距离总和最小是多少。
Solution：
枚举联通分量的根。然后dp。对于节点i，要把k个狐狸分到它和它的子树上。dp[i,j,k]表示以i为根，当前在处理第j棵子树，还有k个狐狸要塞的最小的代价。
那么枚举要给第j棵子树塞k1个狐狸。假设第j棵子树里面已经有x个狐狸，那么转移就是dp[i,j,k]=dp[j,0,k1]+dp[i,j+1,k-k1]+|k1-x|。
相当于，如果k1<x，那么相当于把x-k1个从第j棵子树里面挪出来堆在根上；如果k1>x，那么相当于把k1-x个从根部塞进第j棵子树里面。
要注意的是，枚举k1时始终保持k-k1>=1，这是因为要给根留一个，而代价已经在某棵子树处算过了。

SRM 605 Div1 Med
1-2n(n<=50)个数字分成AB两组，每组n个。两组数字从小到大排列之后，对于第i对，要求|A[i]-B[i]|>=k(k<=10)。问方案数。mod 1e9 + 7。
Solution：
dp。假设我们从小到大把数字分组，那么就是要记下放到第i个数字的时候AB两组此刻的状态。而我们需要的状态是，还没有match的那些数字。那些没match的数字中，
如果已经>=i+k，那么其实只要记下个数就可以了。那么dp[i,j,s]表示当前要放第i个数字时，已经有j个>=i+k的数字，且[i-1,i-k+1]这k-1个数字的状态是s的
方案数。因为k<=10，所以复杂度是n^2*(2^k)。需要特别处理k=1的情况。

SRM 708 Div1 Med
长度为n(n<=3000)的小写字母序列，对于每个i，求出保留s[i]的情况下，挖掉s中其他位置字母后得到回文子序列的方案数f(i)，mod 1e9+7后，将n个值异或。
Solution：
对于每个i，枚举它和s[j]对应。那么所求f(i)即为sigma_j(dp_in(i,j)*dp_out_sum(i-1,j+1))。其中dp_in(i,j)为s[i,j]之间包含s[i],s[j]
且s[i]对应于s[j],的合法回文子序列方案数；dp_out_sum(i-1,j+1)为s[0,i-1]中子序列和s[j+1,n-1]中子序列长度相同且互为回文的子序列方案数。
转移为
dp_in(i,j)={if s[i]==s[j] : dp_in_sum(i+1,j-1)+1 else : 0}
dp_in_sum(i,j) = dp_in_sum(i,j-1) + dp_in_sum(i+1, j) - dp_in_sum(i+1, j-1) + dp_in(i,j)
dp_out(i,j)={if s[i] == s[j] : dp_out_sum(i-1, j+1) else : 0}
dp_out_sum(i,j) = dp_out_sum(i-1,j) + dp_out_sum(i, j+1) - dp_out_sum(i-1,j+1) + dp_out(i,j)。
其中dp_in_sum(i,j)为s[i,j]所有合法回文子序列。
dp_out(i,j)为s[0,i]中子序列和s[j,n-1]中子序列长度相同且包含s[i]和s[j]且互为回文的子序列方案数。

SRM 709 Div1 Easy
给n(n<=15)个数在[0,50]之间，按某种顺序操作。假设上一次操作结果为X,那么下次为X = X + X ^ A[i]。
问使结果最大的操作顺序得到的结果是多少。
Solution：
状压dp。dp[i,j]表示已经处理过的数字的集合是i时，且当前X & 63结果为j时能得到的最大值。
之所以必须要有第二维，是因为前i个数结果大的不一定异或A[i+1]之后还是最大，有后效性。因此异或之后一样的才能取最大。
因为A中数字不超过50，所以只有最后6位有意义。

SRM 709 Div1 Med
长度为n(n<=50)的字母串s，由A/a/B/b组成，每个字符对应[0,3]中的数字。现在每个位置可以a->A,A->a，B->b, b->B，
问怎样换，能使得给定的k(k<=5)个数字(数字范围[0,3])串以对应字母形式出现(可以overlap)在s中的次数最多。返回这个最大次数。
Solution：
dp。dp[i,p,j]表示s的前i个字符的后缀，与k个数字串的前缀匹配最长为第p个数字串的前j个字符。
那么转移的时候，首先构造出这个后缀，然后枚举i+1是否改变，然后找出当前后缀match的最长前缀是np数字串的前nj个字符。
由于我们只是想记下后缀长什么样子，因此只要记下最长的前缀，那么其余短的前缀就也能被cover了。

SRM 711 Div1 Med
给定长度为n(n<=50)的数组a(a中数字<=50)，表示一个大整数X因式分解之后对应第i个素因子p[i]的次数a[i]。
问乘积为X的大于1的不同正整数序列方案数。
Solution：
dp。假设长度为L时，所有的方案就是每个i的C(a[i] + L - 1, L - 1)的乘积。那么使用容斥求出存在一个位置等于1的方案数，
就是枚举j<L，减掉所有的dp[j]*C(L, j)。
Tips：理解容斥的本质！！

SRM 711 Div1 / 2 Hard
m棵树，每棵树n个顶点。按顺序从第i棵树上取下一条边，加到(i+1)%m对应的顶点之间。问使得所得到的新的m棵树都是仍然保持树形结构的方案数mod 1e9+7是多少。
Div2 n,m <= 50, Div1 n,m <= 300.
Solution：
dp[i,j]表示第i棵树取下第j条边后合法的方案数。Div2就可以直接暴力求解了。
对于Div1，要求dp[i+1, j]，假设第i+1棵树第j条边顶点是(u,v)且par[v]=u。那么我们需要的应该是以v为根的子树向u的方向连的所有边k的dp[i,k]的值。
计这个值为F[v]。
这个值可以在算完第i棵树的所有结果之后，枚举第i棵树的每条边O(n)计算出来。假设枚举的边为(u', v')，那么只要把dp[i,k]加到F[u'], F[v']即可。
然后在计算dp[i+1, ...]的值时，按照树的dfs逆序自底向上，一边计算dp值一边累加F[x]值到x各自的父亲节点。
需要注意的是，当计算到lca[u,v]时，dp[i,k](k为(u,v)边的编号)会被累加两遍，然而由于此时边(u,v)变成了同一棵子树中的边，其dp值不应该被计算。
因此要在lca[u,v]处减掉两遍的dp[i,k]。

SRM 712 Div1 Med / Div2 Hard
n(n<=50)个顶点的一棵树T，每个点有个点权w[i]。求T的所有子树T'的Var(T')值的average。
Var(T')定义: ((x1-E(T'))^2 + (x2-E(T'))^2 + ... + (xn-E(T'))^2)/n。其中n为T'中顶点个数。
Solution:
对于一棵子树T',Var(T')推一下可以发现其实就是(x1^2+...+xn^2)/n-(x1+...+xn)^2/n/n。
那么我们可以dp，f[i,j]表示以i为顶点且包含i的且有j个顶点的子树Var值的sum。
num[i,j]表示以i为根且有j个顶点的子树的方案数。sum[i,j]表示以i为根且有j个顶点的子树的w值和。
sum2[i,j]表示平方和。sum3[i,j]表示和平方。
假设枚举到i的儿子i'，有k个儿子。
转移为:
num'[i,j]=num[i,j-k]*num[i',k]
sum'[i,j]=sum[i,j-k]*num[i',k]+sum[i',k]*num[i,j-k]
sum2'[i,j]=sum2[i,j-k]*num[i',k]+sum2[i',k]*num[i,j-k]
必要的奇怪trick来修正精度：
开始时所有权值w[i]要减掉sum(w[i])/n，也就是所有点权w[i]的均值。

SRM 713 Div1 Med / Div2 Hard
n(n<=14)个顶点的无向图，按照下列程序遍历之后得到一个[1-n]的排列。问不同排列方案数。
--------------------------
|root=random(1,n);       |
|list={}                 |
|dfs(root):              |
|  add root to list      |
|  for (v:edges[root])   |
|    if (v not in list)  |
|      dfs(v)            |
--------------------------
Solution:
记忆化dp。f[i,j]表示要遍历当前点集i，以j为root的方案数。
那么就寻找点集i去掉j之后所有的联通块，设为components。
枚举每个components，以及枚举每个components的root。那么f[i,j]=(f[c1,r1]+...+f[c1,rm])*...*(f[cn,r1]+...+f[cn,rm])*fac[num(c)]。

SRM 714 Div1 Med
定义函数f[x]。当x为偶数时，f[x]=x/2；当x为奇数时，f[x]=x+k。其中k为奇数且k<=10^5。
记g[x]为x收敛到小于等于k时的函数调用次数。求[L,R]之间g[x]的和(L,R<=10^16)。
Solution：
dp。sum[x]表示1-x当中g[x]的和。ans=sum[R]-sum[L-1]。
那么对于[1,x]之间的偶数，sume[x]=sum[x/2]+ne(number of even)。对于[1,x]之间的奇数，sumo[x]=sum[(x+k)/2]+2*no(number of odd)。
而sum[(x+k)/2]=sum[x/2]+g[x/2+1]+...+g[(x+k)/2]。
那么对于g[x/2+1]+...+g[(x+k)/2]是可以暴力求解的，因为最多k项。复杂度为k*log(L)^2。

SRM 715 Div1 Med
n(n<=50)个盘子放到3根柱子ABC上,n个盘子按照从小到大编号0-n-1。
求一个答案序列P(P[i]表示第i个盘子放在哪根柱子上)，
使其满足三根柱子上分别有c1,c2,c3个盘子且按照汉诺塔方式全部移到一根柱子上的最少步数是k(k<=2^50-1)。
Solution:
首先确定目标盘子，即最后全部移到哪个盘子上。因为是最少步数，所以必然是最大的盘子所在的柱子。枚举这个柱子是谁。
那么ans = dp[c1,c2,c3-1,"A","B","C",k]+"C" or dp[c1,c3,c2-1,"A","C","B",k]+"B" or dp[c2,c3,c1-1,"B","C","A",k]+"A"。
其中第三个数字和字母表示最后的目标柱子。
接下来在求dp值的时候，也是要枚举最大的盘子在哪根柱子上。
那么dp[c1,c2,c3,a,b,c,k] = dp[c1,c2,c3-1,a,b,c,k]+c
or dp[c1-1,c3,c2,a,c,b,k-2^(c1+c2+c3-1)]+a
or dp[c2-1,c3,c1,b,c,a,k-2^(c1+c2+c3-1)]+b。
在dfs求dp值的时候需要加一个剪枝：
求出(c1,c2,c3)状态下，全部移到目标柱子上的最少步数和最多步数，看k在不在这个范围内。
求minS和maxS的时候也是采用记忆化搜+枚举最大盘子在哪根柱子上的方式。
maxv[c1,c2,c3]表示最大步数，minv[c1,c2,c3]表示最小步数。

SRM 717 Div1 Med / Div2 Hard
给定m(m<=10^5)，D[i]={1,2,...,n+i}(1<=i<=m)的排列中[1,i]不在自己位置上的方案数。
求B[i]=D[i]/n!的异或和。其中(n<=10^9)。
Solution：
dp。D[i]=D[i-1]*(n+i-1)+D[i-2]*(i-1)。
假设我们有n+i-1个数字的排列，当我们插入i这个数字的时候，要么就是这n+i-1个数字已经满足条件，那么可以跟i调换位置的有n+i-1个数字。
要么就是n+i-1个数字还没有满足条件，有一个数字需要跟i调换，那么这种就有i-1种方案。

SRM 719 Div1 Med
n(n<=1000)个顶点的一棵树，每一个顶点有一个点权，可正可负。从顶点0开始遍历，每个点被遍历的第一次就积累这个点的点权，如果当前为负就舍弃。
求能遍历到的点权和的最大值。
Solution：
树上最大字段和。dp[i]表示以i为根的子树的最大和。sum[i]表示以i为根的子树的和(砍掉负值)。
然后dp[i]=max(dp[i],sum[i])。dp[i]+=dp[son[i]], sum[i]+=sum[son[i]]。

TCO17 R2B Div1 Med
n(n<=1000)个顶点的有根树(root=0)。每个顶点有个a-z的小写字母。现在要修改一些小写为大写，满足：
1.每一层上至少一个大写字母。
2.如果一条边的两个端点字母相同，则要么全小写要么全大写。
问方案数。
Solution：
dp。
dpdown[i,s]表示以i为根子树，i为大写或者小写，子树中大写或小写不确定的方案数。
那么答案本应为dpdown[0,0]+dpdown[0,1]。
但是要减掉某一层上全小写的情况。
那么维护数组dplev[i]，表示第i层全小写，[0,i-1]层至少一个大写，i+1层往下不确定的方案数。
也就是，第一层全小写的层为第i层的方案数。
那么对于每一层，假设全为小写，向上dp。dpup[i,s]表示这种情况下第i个顶点为小写或者大写的方案数。
dplev[i]=dpup[0,0]+dpup[0,1]-mulup[j]*dplev[j](0<=j<i)。
其中mulup[j]为第i层全为小写的情况下，导致第j层全为小写的方案数。mulup[j]=dpup[k,0]的乘积，lev[k]=j。
最终答案ans=dpdown[0,0]+dpdown[0,1]-muldown[i]*dplev[i](0<=i<=maxLevel)。其中muldown[i]=dpdown[k,0]的乘积，lev[k]=i。

SRM 723 Div1 Med
给出长度为n(n<=100)的含b,u,f,a,l,o,?的string。问存在多少种方案，使得?填好之后的string是几个"buffalo"的interleave。
Solution：
dp。dp[a,b,c,d,e,f]表示前缀"","b","bu / buf", "buff","buffa","buffal"分别有a,b,c,d,e,f个时的方案数。
特别注意c，也就是"bu / buf"的前缀。我们都用c来表示。因此c的上界要乘2。
转移的时候：
b->bu: c+=2
bu->buf: c-=1
buf->buff: c-=1,d+1
因此如果此时c为奇数，我们知道存在"buf"可以转为"buff"；否则我们知道都是"bu"，需要先转为"buf"。

SRM 724 Div2 Hard
20*20的矩阵表示一些比赛，G[x][y]='W'表示x赢了y，G[x][y]='L'表示x输了y，'?'表示不知道。现在希望给'?'填W或者L，使得这n个人比赛胜率的方差最大。
胜率的定义是，赢的场数/n-1。
Solution：
推一下发现是求赢的场次的平方和最大。
dp。按照赢的次序一个人一个人地加进来。dp[s]表示处理完s集合的人的场次平方和最大值。
新加一个人x进来的时候，要看的是他跟还没加进来的人的关系。

SRM 725 Div1 Med
给出n(n<=14)个顶点，每个顶点有个权值a[i]。问森林的方案数满足森林中每个顶点的b[i]为给定值。答案mod 1e9+7。
其中，定义b[i]为所有i可达的节点的a[i]值的和。
Solution：
按照b[i]值排序。dp[i,j]表示到i为止，有入度的点集合为j的方案数。然后可以预处理i+1顶点儿子集合k，满足!(j&k)时转移。

SRM 726 Div2 Hard
有n(n<=50)个task，每个task有start和finish日期，且<=15。每一天只能做一个task，每个task也只要一天完成。问可以做的task的set有多少种。
Solution：
把task按照{finish, start}从小到大排序，然后状压dp。
dp[i,j]表示前i个task，占用的日期集合是j的选集方案数。那么转移的时候，为了防止重复，对于第i个task，只能放在[start, finish]的第一个合法日期上。

SRM 728 Div1 Med
给定n(n<=300)个区间,1<=L[i]<=R[i]<=10^9,问存在多少合法序列A，满足L[i]<=A[i]<=R[i], A[i]<A[i + 1]。
Solution：
对于A[i],变为A[i]+n-i，那么可以把A[i]<A[i + 1]转化为A[i]<=A[i + 1]。
然后把所有L[i]和R[i]+1离散化，再放上0和∞，得到一个最长为2*n的离散化数组。
然后dp。dp[i][j]表示把第i项放在第j段的方案数。转移即可。

SRM 729 Div1 Hard
长度为n(n<=100)的数组，每个数x[i]可以变为x[i]^x[i - 1]。问经过一些变换之后，可以得到的最长上升子序列长度多长。
Solution：
首先，操作的本质相当于可以给x[i]异或上x[0],...,x[i-1]中的任意一个subset。那么我们可以把x[0],...,x[i-1]变换为一个base vector，也就是，
每个数只保留最高位且它之前的数不要保留这一位。
然后dp。dp[i,j]表示前i个数最长上升子序列长度为j，结尾最小数字是多少。
那么对于x[i]，我们从大到小遍历x[0],...,x[i-1]的这个base vector，记下大于等于dp[i-1][j-1]+1的最小值和小于dp[i-1][j-1]+1的最大值。
维护这两个值，用来更新dp[i][j]。

SRM 730 Div1 Easy
给一棵n(n<=1000)个顶点的树，每个非叶结点最多两个儿子，且两个儿子的编号>=父亲。给出每个顶点的权值，是一个单调递增序列w。从底向上填充节点，
只有x的子树全部填上才能填x。填上x之后可以remove它的儿子。最终填完root游戏结束。问任意一个状态下，使得所有填充节点的w权值和最小，这个最小值是多少。
Solution：
自底向上填充。对于x来说，一定是一个儿子填完再去填另一个最优。所以枚举x的儿子y1,y2，结果就是:
min{max{dp[y1],w[y1]+dp[y2],w[y1]+w[y2]+w[x]}, max{dp[y2],w[y2]+dp[y1],w[y1]+w[y2]+w[x]}}。

SRM 731 Div1 Easy
用长度不超过100的括号序列表示的两棵树t1,t2，每次可以删除t1中的一个叶子结点，问能否经过数次删除后将t1变为t2。
Solution：
将t1,t2变成树，dp[i,j]表示t1的i节点能否变为t2的j节点，记忆化搜。对与i和j，枚举i的儿子x和j的儿子y，如果dp[x,y]=true则x++,y++，否则x++,y不变。
这是因为能匹配就匹配。

SRM 731 Div1 Med
一棵无穷节点的完全二叉树，节点初始全白，每次从根出发，随机选择一个儿子往下走，遇到还是白色就涂红。问涂红k(k<=2000)节点时，
红色节点两两间路径长度的期望是多少。
Solution：
期望dp。dp[i,0]表示i个节点两两间路径长度的期望，dp[i,1]表示i个节点到根路径长度的期望。
则枚举i的x个儿子去左节点，则y=i-1-x个儿子去右节点。
dp[i,0]=(dp[x,0]+dp[y,0]+(dp[x,1]+x)*(y+1)+(dp[y,1]+y)*(x+1))*C(i,x)*(1/2^(i-1));
dp[i,1]=(dp[x,1]+dp[y,1]+i-1)*C(i,x)*(1/2^(i-1)).

TCO 18 R2B Med
n(n<=1000)个位置，每个位置有个number(number<=10^6)。给每个位置染色，相邻位置不同色。每种颜色取number的最大值，对每种颜色求和。
问这个和最小是多少。
Solution:
首先观察最多不超过三种颜色。
全局最大值必须要取到最终结果中。
考察三种颜色的情况，枚举最大值最小的那一组的最大值。
然后dp第三组的最大值最小是多少。
dp[i,j]表示到第i个位置，前个位置分在第j组，中间组的最大值最小。

SRM 740 Div1 Med
A有一个n(n<=30)面的骰子，每个面有个数字在[0,5000]。点数总和不变，重新分布给B的一个n面骰子，使得扔一次B赢的概率最大。输出一种分布方案。
Solution：
n^4的dp。dp[i,j]表示到第i个位置，B大于A的面数和为j时，用掉的点数最小和。
转移的时候枚举当前位置要大于的面数k，然后用掉的点数为pips[k]+1即可。
找方案可以用pre[i,j]=k记录下来。

SRM 741 Div1 Easy
长度为n(n<=50)的数字串，砍掉其中一些字符，使得得到的数字串没有前导0且>x。问方案数。
Solution：
从最低位到最高位dp。dp[i,j,z,k]表示s的最后i位中保留了j位，首位是不是0，跟x的最后j位比是大于小于等于的方案数。

SRM 742 Div1 Med
n(n<=15)个长度不超过50的串，random一下顺序，然后按照顺序接起来。给定长度不超过50的目标串，问目标串在连接之后的串中出现的期望。
Solution：
按照一个一个把串接到总串上的顺序dp。
dp[i,j]表示未用的串集合为i，目标串的待匹配的位置为j的概率。用类似kmp预处理出nxt[j,k]表示目标串待匹配位置为j，
把k串放到末尾之后跳转到目标串待匹配位置为k。用这个nxt数组来转移。
同时求出cnt[j,k]表示目标串待匹配位置为j，把k串放到末尾之后增加了多少个目标串。转移的时候用dp[i,j]/bits(i) * cnt[j,k]来累加期望。

SRM 743 Div1 Med
长度为50的序列，每个数字范围[0, 50]。在每个数字前面加上正号或者负号，给出负号概率序列ProbMinus。
求最大字段和的值的期望。
Solution：
dp[i,j,k]表示前i个数，当前和为j，最大字段和为k的概率。

SRM 747 Div1 Med
t(t<=50)个token放到p(p<=50)堆里，随机放，问最后有多堆最大值的概率。
Solution：
有多堆最大值的概率=1.0 - 只有一堆最大值的概率！！！
枚举最大值mx，然后求出dp[p-1][t-mx]，其中每一堆不超过mx。
然后结果就是dp[p-1][t-mx]*C(t,mx)*p的和除以p^t。然后用1.0减去这个概率就可以了。

SRM 752 Div1 Med
3n(n<=1000)张卡片编号1-3n，分给三个人，每人n张。三人轮流，每次从自己没有的2n张牌中随机选一张X说出来。
已知A的n张牌以及已经进行了m(m<=200)轮的X的结果，问A知道三张牌分布情况的期望轮数(包括开始已经知道结果的m轮)。
Solution：
直接dp啦。dp[i,j,k]表示B知道了i张C知道了j张当前应当是A/B/C，到终点的期望步数。因此i==n|j==n时答案是0。
方程dp[i,j,0/1/2]写出来会发现有环，因此几个式子互相代一代可以消去一些东西先求出dp[i,j,0]用dp[i,j+1,A/B/C]和dp[i+1,j,A/B/C]表示的表达式。
开始给出的m轮可以用于计算最终取解的时候dp[n1,n2,0]的n1和n2。

SRM 756 Div1 Hard
给出一个50×50矩阵，'x'表示special cell，'.'表示inactive cell，'#'表示active cell，'*'表示undecided cell。
现在要给每个'*'指定为inactive或者active，然后相邻的active cell连边('x'也是active cell)。
然后给每条边用红蓝黄其一色染色，问有多少指定cell的方法使得存在一种染色方案，使得所有special cell没有同色的相邻边。答案mod 1e^9+7。
Solution：
1. 如果不跟special cell相邻的'*'那么就是free cell随便指定，每个cell有两种方案。否则要看相邻的special cell的情况。
2. 每个special cell如果周围存在至少一个不可能为active的cell，那么这个special cell就是不需要考虑的，一定存在一种方案可以让它的相邻边不同色。
3. 对于相邻四个可能全为active的special cell，设为interesting cell。每个非free的'*'把它周围四个interesting cell的情况状态压缩。
4. 每个非free cell指定为inactive时会free掉它mask的周围的interesting cell。状压dp求出把所有interesting cell全部free的方案数。
5. 最终结果再乘以2^(# of free cell)次幂。
