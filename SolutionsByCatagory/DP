SRM 644 Div1 Med
N=10^15个人，进行K<=6轮比赛。每轮将现有人数分成R个room，每个room人数不少于2。每个room一人胜出，进行下一轮room划分和比赛。最终K轮之后至少1人胜出。
问room划分总方案数。
Solution:
给N个叶节点，组成一棵K层的树，使得除了叶节点以外每个节点儿子数>=2。问构造方案数。
由于6比较小，6!又不可能。。。考虑2^6的算法。。。
假设我们从左到右把叶子节点加进来，那么当前刚加入的叶子节点和总的root之间的这条路径以左的非叶节点必然已经满足儿子数>=2的条件了。
那么就看这条路径上的节点的状态。用0表示儿子数为1，用1表示儿子数>=2。就可以得到2^6的状态了。
转移的时候，从最低位到最高位，第一个0以及比它低位的所有1都可以作为新的分叉点。
比如10111可以转移到10111, 10110, 10100, 11000。
于是我们得到2^6 * 2^6的转移矩阵。之后用矩阵快速幂求即可。
需要注意的是，因为最终可能不止一人胜出。于是要加一个虚拟根节点变成k + 1层。
而取解的时候变成同时取出res[(1<<K) - 1][0] + res[(1<<(K + 1)) - 1][0]即可。

SRM 647 Div1 Med
n<=500个机器人，价钱cost油量cap，从原点出发向右运动，每秒钟耗费1unit油。
每个时刻每个机器人可以选择反向回去，保证油量能返回原点的情况下剩余油量送给下一个机器人。
有总钱数B<=10000，买一些机器人，要使得最后剩下的机器人走得最远。问有多远。
Solution：
假设已经买定一个set的机器人，如何最远？首先一定是cap小的把油给cap大的。设capA < capB,t时刻后返回，那么送出的油量是min(capA-2t, t)。
画图分析，极值点取在capA/3处。那么这两个可以合并成capB + capA/3。多个的以此类推。至于买哪些，直接dp即可。

SRM 647 Div2 Hard
给10^9个building设定高度，满足building[1]=0，相邻两个building高度delta<=k(k<=10^9)，所有高度非负数。
且满足，给定x(size<=500)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
不能枚举最大高度是哪个，但是可以二分最大高度是多少。对于一对(x,t)，二分的最大高度是h，那么h和x的距离d>=(h-t-1)/k。
因此有非法区间[max(1,x-d),min(x+d,n)]。取所有非法区间的并集，看补集是否为空。

SRM 652 Div1 Med
n<=1000个点，m<=2500条边的有向图。每条边上有个cost。A想尽量快地从0到n－1，B有k<=1000个token，想尽量阻止A到达n-1，如果不能，就让A尽量晚到。
每次A会告诉B她要走的边，B可以选择使用token改变A要走的边，也可以选择不使用。问双方都最优策略，A多久到n－1。
Solution：
dp[i,j]表示在i节点，已经使用了j张token要到达n-1所要花费的最小cost。
那么在i节点，A要选择的是所有临接节点里面dp[k,j]最小的，而B要选择的是所有dp[k,j+1]里面最大的。然后从n节点倒着dp回0节点即可。
几个技巧：
1）可以以k划分阶段，滚动优化。
2）每次可以预处理出B的选择，以便在i+1时可以直接用。

SRM 655 Div1 Med
5000个位置填[0,9]的数字，N=5个问题。每个数字对应一个mask，表示这个数字会出现在第几个问题里。
对于每个问题，按顺序读会出现的数字之后会组成一个十进制数，问所有N个问题得到的十进制数mod9都为0的方案数。
Solution:
注意到每个数字只会影响mask所包含这几个问题的结果，那么可以按照这个mask把数字归类，统计这一类中各位数字mod9的结果，先dp预处理出来。
然后把每个mask对应的结果放到总的结果里。
然后这个实现的时候还有个点，添加每个mask对应结果的时候，按照mask从小到大正常地状压dp就可以了。

SRM 656 Div2 Hard
有多少1-n(n<=200)的排列满足当且仅当下标idx在给定数组pos(size<=200)时，p[idx]<p[idx+1]。答案mod 1e9+7。
Solution:考察折线的每个极小值点。用dp[i,j]表示[i,j]的方案数，那么j-i+1个数的最小值必然是放在极小值。
然后可以分成两段。dp[i,j]=dp[i,k-1]*dp[k+1,j]*C(j-i+1,k-i)。

SRM 658 Div1 Med
有n<=20个敌军，每人血量<=60。每次可以开一枪，选一个人掉血9，一个人6，一个人3。三者不能是同一个人。问杀死所有人最少开多少枪。
Solution：
二分开枪数m。dp[i,n9,n3]表示前i个SCV用了n9个9和n3个3消耗的最少的1的个数。枚举时满足条件对一个敌军，n1+n3+n9<=m。

SRM 660 Div1 Med
n<=50个人，每个人有个讨厌的人。随机地邀请这些人，如果他讨厌的人没来他就来。问来人数的期望。
Solution：
分情况讨论。
先看链。只跟长度有关。枚举去掉哪个点，dp。
看环。去掉一个点，转成链。
看带链的环。去掉链上的点好说；去掉环上的点会变成“Y”字形。设三条arm分别为a,b,c，那么根据独立性，这个“Y"字形的答案就是f(a + c) + f(b + c) - f(c)。
综上所述，对于一个点，如果是在环上，求环的期望，又因为环上每个点的对称性，除以环长得出每个点的概率；
如果在链上，求它距离环的距离，设为d，连接的环长为r，根据独立性，那么答案就是f[d][r] - f[d - 1][r]。
找环的时候这个“追击”的方法竟然是floyd发明的？！
确定连接环的链长，方法是，找到环的时候两者相遇在环上的位置是p,那么从p和链的起始s，同时前进，相遇的位置即为环开始的地方，走过的长度即为连接环的链长。

SRM 661 Div1 Med
n<=10^12个点，每个点k<=10^12种可涂的颜色。每个点i可以向j(j < i)连边，问图的不同方案数mod m(m<=10^6)。
Solution：
直接dp。m较小，按照mod值分类。

SRM 663 Div2 Hard
n(n<=16 and will be power of 2)个人比赛，每两个人一组，胜者继续。问最后每个人分别有多少种方案数可以赢。
Solution：
dp[i,j]表示集合i包含的人当中j胜出的方案数。

SRM 664 Div1 Med
n(n<=10^6)个顶点的一棵树，对每个顶点攻击一次。攻击之后保留这个点的概率是1/(i+1)，i/(i+1)的概率这个点以及联通它的边消失。
设攻击完之后剩余联通分量顶点个数分别为n1,n2...nk。求n1^2+n2^2+...+nk^2的期望*N!之后mod 1e9+7。
Solution：
(a+b)^2=a^2+b^2+a*b+b*a。实际是两两相乘。
那么nk^2实际上可以转化成联通分量里联通的顶点pair(u, v)的对数。这样就可以对每一个pair计数概率。dp[u]表示以u为根的子树中，含u的pair出现的概率。
generate法则保证儿子的标号大于父亲的标号，因此从大到小枚举即可。

SRM 666 Div1 Med
对于n(n<=4000)个数的排列，按照排列各个位置上数字去放东西。比如(p1, p2, p3)=(1,3,2)，那么先在1上放一个，再在3上放一个，最后在2上放一个。
每次放的时候给结果乘以一个(n-x)其中x为当前放的位置的左右两边已经有的东西的个数。然后求所有排列的这个值的和。
Solution：
dp[i]表示前i个数的排列的和，那么第i + 1个数可以放在两端，也可以放在中间。

SRM 669 Div1 Med
n(n<=200)个点的完全图，每条边边权是[1,l(l<=200)]。对于l^(n*(n-1)/2)种图中的每一个，count线型生成树的个数，然后对所有图加和。问和是多少。
Solution：
dp[i,j]表示前i条边，线型MST上最大色为j时的方案数。这里要枚举第一条最大的边是哪一条(比如为k)，
然后将这i个点分成了两个部分，前k-1条边最大色为j - 1，后面i-k条边上的最大色则为j。然后跨两部分的边的可选色为l-j+1，则转移为:
dp[i,j]=dp[k,j-1]*dp[i-k,j]*((l-j+1)^((k-1)*(i-k)))。

SRM 672 Div1 Med
求n(n<=2000)个点(无自环无重边无向图)的近欧拉图有多少种，结果mod 1e9+7。近欧拉图包括欧拉图＋加一条边/减一条边能变成欧拉图的图。
Solution：
由近欧拉图得到欧拉图，图中有不超过一对奇度点，连接or删掉这对点之间的边即可。因此每一个欧拉图对应n(n-1)/2+1个近欧拉图。
设n个点欧拉图方案数为E。欧拉图定义为：每个点degree为偶数且联通。那么我们可以求出degree全为偶数的图的方案数(设为D)再减掉不联通的那些(设为R)。
对于D，每一个n-1个顶点的图都对应一个n顶点的degree全偶的图(第n个点补上缺掉的degree就行)，因此方案数2^((n-1)*(n-2)/2)。
对于R，如果不联通必然包含多个联通分量。假设1所在的分量有k个点，那么就有C(n-1,k-1)*(Dk-Rk)*Dn-k。因此E=D-R，求出即可。

SRM 673 Div1 Med
求1-n(n<=100)的每个排列所对应的Cartesian树中得分<=s(s<=100)的方案数。
Cartesian树定义：小根堆二叉树，中序遍历此树能得到对应排列。
得分计算方法：对于树中有两个儿子的顶点，找出两个儿子在原排列中的对应下标差，sum up所有这样的值。
Solution：
dp[i,j]表示i个数和为j的方案数。转移的时候枚举左边根下标idx1和s1，右边根下标idx2和s2。
那么可以预处理出sum[s1+abs(k-idx1)]和sum[s2+abs(k-idx2)]，其中k为i个数中的根的下标(即i个数中的最小值)。

SRM 675 Div1 Hard
问能否构造出n(n<=50)个顶点和exactly有s(s<=1000)条长度为2的path的树。
Solution：
直接dp。dp[i,j,k]表示i个点有j个叶子长度为2的path条数为k是否可能。

SRM 677 Div1 Med(🌲dp)

SRM 684 Div1 Med
n(n<=50000)个数的sequence，每个数在1到k(k<=50000)范围内。问有多少符合条件的序列。条件：对i,a[i]<=a[i+1] or a[i] % a[i+1] != 0。
Solution：容斥思想。good(n)=k^n-bad(n)。
bad(n)=bad(n-1)*k + good(n-2)*seq(2)。其中seq(2)是a[i]%a[i+1]=0的pair。
然而，当我们把pair加到末尾的时候可能会导致good(n-2)中的最后一个和加进来的第一个数组成bad pair，因此要-good(n-3)*seq(3)。这样只要一直容斥就可以了。
另外seq的长度因为是指数增长，因此不会超过log2(k)。对于seq直接dp计数即可。

SRM 686 Div2 Hard
n(n<=100)个"("和")"的括号序列，问不同的非空合法括号序列有多少种。
Solution：
dp[i,j]表示前i个位置多余j个"("的序列方案数。那么枚举下一个的时候，关键不是位置，而是是"("还是")"。因此就枚举是"("还是")"，
相应地选择第一个出现的位置转移即可。

SRM 690 Div1 Med
n(n<=10^5)个顶点的无向🌳，给每条边加个方向得到一个有向图。对于这个有向图求出有多少unordered pair(x,y)使得x->y有一条路径。
求所有2^(n-1)这样的有向图的unordered pair和。
Solution：
每条长度为k的路径贡献2^(n-1-k)=2^(n-1) / 2^k。那么dp路径，每次加一条边就乘一次2^(-1)。

SRM 690 Div2 Hard
在2*n(n<=1000)的格子上安排0-2*n-1的🐺站位。问有多少种满足条件的方案。
条件：1）每一行至少有一个编号>=k的🐺；2）按顺序写出每一列的编号较大值和每一行编号最大值得到n+2的序列，序列不同则为不同方案。
Solution：
首先关注行的最大值可以取多少。假设和2n-1放在同一行的数是[2n-1, m]，而第一个和2n-m中的某一个数放在同一列的是m-1，那么两行的最大值的不同组合
是2*(2n-m-1)(特别地，m<=k的时候只能取到2*(2n-k-1))。剩下的就是要求列的较大值的组合情况。可以直接dp。
dp[i,j]表示当前要放1-i的数字，而和2n-1在同一行的位置还有j个，列的不同较大值组合的方案数。那么对于i，可以把它塞到和[i+1, 2n-1]同一列，
也可以让它新开一列，成为某一列的较大值。最后列的结果乘上n!再乘上行的最大值的方案数即可。

SRM 693 Div1 Easy
n(n<=100)个顶点，对于每个i,i+1有一条权值为w1[i]的边，对于每个i,i+2有一条权值为w2[i]的边。问从图中删掉权值和最大的边，使得剩下的图为
2-edge connected，则剩下的边权值总和最小多少。
2-edge connected定义：任意一对顶点之间至少有两条不相交的路径。
Solution：
最后结果应该是一些环相互连接。如果有6个点，那么最后会是类似于0-1-2-0+2-4-5-3-2这样。设每个点有三种状态，即作为环的起点，终点和中间节点。
那么dp[i,j]就表示第i个点状态为j时候的最小边权和。之后转移。

SRM 694 Div1 Med
n(n<=1000)个人，m(m<=20)个问题，mat[i,j]=['A','Z']。问能把所有人区分开来的问题集合有多少个。
Solution：
预处理出任意两个人的答案相同的问题集合，则这个问题集合以及这个集合的子集是不可以的。状压dp从大到小推。

SRM 696 Div1 Easy
50个点的图，有m(m<=20)条无向边。要给所有点涂色，每次涂色花费是所有两端点都已被涂的边条数和。问最小代价。
Solution：
状压dp。dp[i]表示边集i被选进来的代价。枚举去掉某一条边的某个顶点，则去掉这个顶点的所有临接边的边集j，由dp[i^j]转移到dp[i]。

SRM 696 Div2 Hard
n(n<=20)个顶点个无向图，给出边的邻接矩阵，最多m(m<=20)组关系缺失。问2^m种不同的图，各自求最大团之后加和是多少。
Solution：
枚举每个顶点集合，求出使这个顶点集合x为最大团所必要的缺失边集合s，则更新dp[s]=max(dp[s],x)。
之后枚举缺失边i得到s的超集(s|(1<<i))，更新dp[s|(1<<i)]=max(dp[s|(1<<i)],dp[s])。

SRM 697 Div2 Hard
n(n<=1000)个选手参加2^m(m<=30)天比赛，每个选手有个a[i](0<=a[i]<2^m)能力值，第j天比赛时，把所有人的a[i]和j异或，按照从小到大排序。
每个人得分排名的平方。求每个人2^m天得分总和mod 1e9+7之后的和。
Solution:
对每个人算出排名第x的方案数。dp[b,r]表示在考察a[i]的第b位，排名第r位的方案数。然后枚举第b位是0/1转移。

SRM 698 Div2 Hard 🌲🌳🌴
n(n<=50)个点的一颗无向树，每个顶点有个权值。问每一棵子树上所有顶点权值求or之后得到的值的和是多少。
Solution：
拆位＋求补集。对于每一位，求出or之后含这一位的子树有多少。可以用补集，即求出or之后不含这一位的子树有多少。dp[b,i]表示经过顶点i的，or的结果不含第b位的
子树总数。

SRM 701 Div1 Med
长度为n(n<=50)的string，对于每个0<i<2^n，从小到大扫i的每一位b，如果b是1的话就把s的最后b+1个字符翻转，最终扫完得到一个t。对于所有的t的集合，
找到字典序第k小的string。
Solution：
对于每一位从a到z枚举，然后dp出与当前前缀match的string方案数。注意到这个集合生成方式实际上就是，从0到n-1地枚举s的每一位，
选择把这一位从外往里地加入到t的两侧。比如t的前缀为i，后缀为j，那么s的第i+j+1个字符就可以加到前面的第i+1个和倒数的第j+1个。
因此dp[i,j]表示用了s的前i个字符，其中前缀长度为j的方案数。那么第i+1个字符可以放到j+1或者n-(i-j)个位置，但是要注意与前面枚举的前缀match。

SRM 702 Div1 Med
问长度为n(n<=150)的string，good的子序列排第k大的是谁。good定义：()或者(SSS),其中S为good string。
Solution：
首先dp出来长度为x的good string方案数，发现总数并不多(total 9526 when n <= 150)。然后暴力生成暴力check是否匹配即可。

SRM 703 Div1 Med

SRM 704 Div2 Hard
长度为n(n<=10^9)的序列，每个数[0,k)(k<=100)。问多少序列满足乘积mod k = v。结果mod 1e9+7。
Solution：
快速矩阵幂。构造一个矩阵满足a[i][j]是前面mod k = i时，再乘一个数转移到j的方案数。

SRM 603 Div1 Med
问有多少合法的串对(A,B)满足，|A|=|B|=n(n<=10^9)且AB中的字符均属于前k个小写字母且存在一个C满足A+C=C+B。
Solution：
首先满足条件的A和B必然是形如(x+y,y+x)的形式，即B是A的一个rotation。那么看一个A会有多少个不同的rotation，这取决于A中最长的循环节长度。
对于循环节长度为d的A，方案数有f[d]*d。那么可以dp这个f[d]，但是要注意减掉d' < d && d' | d的f[d']。最终求出g[d]，即以d为最长循环节的串的方案数。

SRM 604 Div1 Med
n(n<=50)个顶点的一棵树，某些顶点里有狐狸。这些狐狸要移动到一个联通的子树里面，子树中的每个节点有一个狐狸。问所有狐狸移动的距离总和最小是多少。
Solution：
枚举联通分量的根。然后dp。对于节点i，要把k个狐狸分到它和它的子树上。dp[i,j,k]表示以i为根，当前在处理第j棵子树，还有k个狐狸要塞的最小的代价。
那么枚举要给第j棵子树塞k1个狐狸。假设第j棵子树里面已经有x个狐狸，那么转移就是dp[i,j,k]=dp[j,0,k1]+dp[i,j+1,k-k1]+|k1-x|。
相当于，如果k1<x，那么相当于把x-k1个从第j棵子树里面挪出来堆在根上；如果k1>x，那么相当于把k1-x个从根部塞进第j棵子树里面。
要注意的是，枚举k1时始终保持k-k1>=1，这是因为要给根留一个，而代价已经在某棵子树处算过了。

SRM 605 Div1 Med
1-2n(n<=50)个数字分成AB两组，每组n个。两组数字从小到大排列之后，对于第i对，要求|A[i]-B[i]|>=k(k<=10)。问方案数。mod 1e9 + 7。
Solution：
dp。假设我们从小到大把数字分组，那么就是要记下放到第i个数字的时候AB两组此刻的状态。而我们需要的状态是，还没有match的那些数字。那些没match的数字中，
如果已经>=i+k，那么其实只要记下个数就可以了。那么dp[i,j,s]表示当前要放第i个数字时，已经有j个>=i+k的数字，且[i-1,i-k+1]这k-1个数字的状态是s的
方案数。因为k<=10，所以复杂度是n^2*(2^k)。需要特别处理k=1的情况。

SRM 708 Div1 Med
长度为n(n<=3000)的小写字母序列，对于每个i，求出保留s[i]的情况下，挖掉s中其他位置字母后得到回文子序列的方案数f(i)，mod 1e9+7后，将n个值异或。
Solution：
对于每个i，枚举它和s[j]对应。那么所求f(i)即为sigma_j(dp_in(i,j)*dp_out_sum(i-1,j+1))。其中dp_in(i,j)为s[i,j]之间包含s[i],s[j]
且s[i]对应于s[j],的合法回文子序列方案数；dp_out_sum(i-1,j+1)为s[0,i-1]中子序列和s[j+1,n-1]中子序列长度相同且互为回文的子序列方案数。
转移为
dp_in(i,j)={if s[i]==s[j] : dp_in_sum(i+1,j-1)+1 else : 0}
dp_in_sum(i,j) = dp_in_sum(i,j-1) + dp_in_sum(i+1, j) - dp_in_sum(i+1, j-1) + dp_in(i,j)
dp_out(i,j)={if s[i] == s[j] : dp_out_sum(i-1, j+1) else : 0}
dp_out_sum(i,j) = dp_out_sum(i-1,j) + dp_out_sum(i, j+1) - dp_out_sum(i-1,j+1) + dp_out(i,j)。
其中dp_in_sum(i,j)为s[i,j]所有合法回文子序列。dp_out(i,j)为s[0,i]中子序列和s[j,n-1]中子序列长度相同且包含s[i]和s[j]且互为回文的子序列方案数。

SRM 709 Div1 Easy
给n(n<=15)个数在[0,50]之间，按某种顺序操作。假设上一次操作结果为X,那么下次为X = X + X ^ A[i]。
问使结果最大的操作顺序得到的结果是多少。
Solution：
状压dp。dp[i,j]表示已经处理过的数字的集合是i时，且当前X & 63结果为j时能得到的最大值。
之所以必须要有第二维，是因为前i个数结果大的不一定异或A[i+1]之后还是最大，有后效性。因此异或之后一样的才能取最大。
因为A中数字不超过50，所以只有最后6位有意义。

SRM 709 Div1 Med
长度为n(n<=50)的字母串s，由A/a/B/b组成，每个字符对应[0,3]中的数字。现在每个位置可以a->A,A->a，B->b, b->B，问怎样换，能使得给定的k(k<=5)个数字
(数字范围[0,3])串以对应字母形式出现(可以overlap)在s中的次数最多。返回这个最大次数。
Solution：
dp。dp[i,p,j]表示s的前i个字符的后缀，与k个数字串的前缀匹配最长为第p个数字串的前j个字符。那么转移的时候，首先构造出这个后缀，然后枚举i+1是否改变，然后
找出当前后缀match的最长前缀是np数字串的前nj个字符。
由于我们只是想记下后缀长什么样子，因此只要记下最长的前缀，那么其余短的前缀就也能被cover了。

SRM 711 Div1 Med
给定长度为n(n<=50)的数组a(a中数字<=50)，表示一个大整数X因式分解之后对应第i个素因子p[i]的次数a[i]。
问乘积为X的大于1的不同正整数序列方案数。
Solution：
dp。假设长度为L时，所有的方案就是每个i的C(a[i] + L - 1, L - 1)的乘积。那么使用容斥求出存在一个位置等于1的方案数，
就是枚举j<L，减掉所有的dp[j]*C(L, j)。
Tips：理解容斥的本质！！

SRM 711 Div1 / 2 Hard
m棵树，每棵树n个顶点。按顺序从第i棵树上取下一条边，加到(i+1)%m对应的顶点之间。问使得所得到的新的m棵树都是仍然保持树形结构的方案数mod 1e9+7是多少。
Div2 n,m <= 50, Div1 n,m <= 300.
Solution：
dp[i,j]表示第i棵树取下第j条边后合法的方案数。Div2就可以直接暴力求解了。
对于Div1，要求dp[i+1, j]，假设第i+1棵树第j条边顶点是(u,v)且par[v]=u。那么我们需要的应该是以v为根的子树向u的方向连的所有边k的dp[i,k]的值。
计这个值为F[v]。
这个值可以在算完第i棵树的所有结果之后，枚举第i棵树的每条边O(n)计算出来。假设枚举的边为(u', v')，那么只要把dp[i,k]加到F[u'], F[v']即可。然后在计算
dp[i+1, ...]的值时，按照树的dfs逆序自底向上，一边计算dp值一边累加F[x]值到x各自的父亲节点。
需要注意的是，当计算到lca[u,v]时，dp[i,k](k为(u,v)边的编号)会被累加两遍，然而由于此时边(u,v)变成了同一棵子树中的边，其dp值不应该被计算。
因此要在lca[u,v]处减掉两遍的dp[i,k]。

SRM 712 Div1 Med / Div2 Hard
n(n<=50)个顶点的一棵树T，每个点有个点权w[i]。求T的所有子树T'的Var(T')值的average。
Var(T')定义: ((x1-E(T'))^2 + (x2-E(T'))^2 + ... + (xn-E(T'))^2)/n。其中n为T'中顶点个数。
Solution:
对于一棵子树T',Var(T')推一下可以发现其实就是(x1^2+...+xn^2)/n-(x1+...+xn)^2/n/n。
那么我们可以dp，f[i,j]表示以i为顶点且包含i的且有j个顶点的子树Var值的sum。
num[i,j]表示以i为根且有j个顶点的子树的方案数。sum[i,j]表示以i为根且有j个顶点的子树的w值和。
sum2[i,j]表示平方和。sum3[i,j]表示和平方。
假设枚举到i的儿子i'，有k个儿子。
转移为:
num'[i,j]=num[i,j-k]*num[i',k]
sum'[i,j]=sum[i,j-k]*num[i',k]+sum[i',k]*num[i,j-k]
sum2'[i,j]=sum2[i,j-k]*num[i',k]+sum2[i',k]*num[i,j-k]
必要的奇怪trick来修正精度：
开始时所有权值w[i]要减掉sum(w[i])/n，也就是所有点权w[i]的均值。

SRM 713 Div1 Med / Div2 Hard
n(n<=14)个顶点的无向图，按照下列程序遍历之后得到一个[1-n]的排列。问不同排列方案数。
--------------------------
|root=random(1,n);       |
|list={}                 |
|dfs(root):              |
|  add root to list      |
|  for (v:edges[root])   |
|    if (v not in list)  |
|      dfs(v)            |
--------------------------
 Solution:
 记忆化dp。f[i,j]表示要遍历当前点集i，以j为root的方案数。
 那么就寻找点集i去掉j之后所有的联通块，设为components。
 枚举每个components，以及枚举每个components的root。
