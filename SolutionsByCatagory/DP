SRM 644 Div1 Med
N=10^15个人，进行K<=6轮比赛。每轮将现有人数分成R个room，每个room人数不少于2。每个room一人胜出，进行下一轮room划分和比赛。最终K轮之后至少1人胜出。
问room划分总方案数。
Solution:
给N个叶节点，组成一棵K层的树，使得除了叶节点以外每个节点儿子数>=2。问构造方案数。
由于6比较小，6!又不可能。。。考虑2^6的算法。。。
假设我们从左到右把叶子节点加进来，那么当前刚加入的叶子节点和总的root之间的这条路径以左的非叶节点必然已经满足儿子数>=2的条件了。
那么就看这条路径上的节点的状态。用0表示儿子数为1，用1表示儿子数>=2。就可以得到2^6的状态了。
转移的时候，从最低位到最高位，第一个0以及比它低位的所有1都可以作为新的分叉点。
比如10111可以转移到10111, 10110, 10100, 11000。
于是我们得到2^6 * 2^6的转移矩阵。之后用矩阵快速幂求即可。
需要注意的是，因为最终可能不止一人胜出。于是要加一个虚拟根节点变成k + 1层。
而取解的时候变成同时取出res[(1<<K) - 1][0] + res[(1<<(K + 1)) - 1][0]即可。

SRM 647 Div1 Med
n<=500个机器人，价钱cost油量cap，从原点出发向右运动，每秒钟耗费1unit油。
每个时刻每个机器人可以选择反向回去，保证油量能返回原点的情况下剩余油量送给下一个机器人。
有总钱数B<=10000，买一些机器人，要使得最后剩下的机器人走得最远。问有多远。
Solution：
假设已经买定一个set的机器人，如何最远？首先一定是cap小的把油给cap大的。设capA < capB,t时刻后返回，那么送出的油量是min(capA-2t, t)。
画图分析，极值点取在capA/3处。那么这两个可以合并成capB + capA/3。多个的以此类推。至于买哪些，直接dp即可。

SRM 647 Div2 Hard
给10^9个building设定高度，满足building[1]=0，相邻两个building高度delta<=k(k<=10^9)，所有高度非负数。
且满足，给定x(size<=500)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
不能枚举最大高度是哪个，但是可以二分最大高度是多少。对于一对(x,t)，二分的最大高度是h，那么h和x的距离d>=(h-t-1)/k。
因此有非法区间[max(1,x-d),min(x+d,n)]。取所有非法区间的并集，看补集是否为空。

SRM 652 Div1 Med
n<=1000个点，m<=2500条边的有向图。每条边上有个cost。A想尽量快地从0到n－1，B有k<=1000个token，想尽量阻止A到达n-1，如果不能，就让A尽量晚到。
每次A会告诉B她要走的边，B可以选择使用token改变A要走的边，也可以选择不使用。问双方都最优策略，A多久到n－1。
Solution：
dp[i,j]表示在i节点，已经使用了j张token要到达n-1所要花费的最小cost。
那么在i节点，A要选择的是所有临接节点里面dp[k,j]最小的，而B要选择的是所有dp[k,j+1]里面最大的。然后从n节点倒着dp回0节点即可。
几个技巧：
1）可以以k划分阶段，滚动优化。
2）每次可以预处理出B的选择，以便在i+1时可以直接用。

SRM 655 Div1 Med
5000个位置填[0,9]的数字，N=5个问题。每个数字对应一个mask，表示这个数字会出现在第几个问题里。
对于每个问题，按顺序读会出现的数字之后会组成一个十进制数，问所有N个问题得到的十进制数mod9都为0的方案数。
Solution:
注意到每个数字只会影响mask所包含这几个问题的结果，那么可以按照这个mask把数字归类，统计这一类中各位数字mod9的结果，先dp预处理出来。
然后把每个mask对应的结果放到总的结果里。
然后这个实现的时候还有个点，添加每个mask对应结果的时候，按照mask从小到大正常地状压dp就可以了。

SRM 656 Div2 Hard
有多少1-n(n<=200)的排列满足当且仅当下标idx在给定数组pos(size<=200)时，p[idx]<p[idx+1]。答案mod 1e9+7。
Solution:考察折线的每个极小值点。用dp[i,j]表示[i,j]的方案数，那么j-i+1个数的最小值必然是放在极小值。
然后可以分成两段。dp[i,j]=dp[i,k-1]*dp[k+1,j]*C(j-i+1,k-i)。

SRM 658 Div1 Med
有n<=20个敌军，每人血量<=60。每次可以开一枪，选一个人掉血9，一个人6，一个人3。三者不能是同一个人。问杀死所有人最少开多少枪。
Solution：
二分开枪数m。dp[i,n9,n3]表示前i个SCV用了n9个9和n3个3消耗的最少的1的个数。枚举时满足条件对一个敌军，n1+n3+n9<=m。

SRM 660 Div1 Med
n<=50个人，每个人有个讨厌的人。随机地邀请这些人，如果他讨厌的人没来他就来。问来人数的期望。
Solution：
分情况讨论。
先看链。只跟长度有关。枚举去掉哪个点，dp。
看环。去掉一个点，转成链。
看带链的环。去掉链上的点好说；去掉环上的点会变成“Y”字形。设三条arm分别为a,b,c，那么根据独立性，这个“Y"字形的答案就是f(a + c) + f(b + c) - f(c)。
综上所述，对于一个点，如果是在环上，求环的期望，又因为环上每个点的对称性，除以环长得出每个点的概率；
如果在链上，求它距离环的距离，设为d，连接的环长为r，根据独立性，那么答案就是f[d][r] - f[d - 1][r]。
找环的时候这个“追击”的方法竟然是floyd发明的？！
确定连接环的链长，方法是，找到环的时候两者相遇在环上的位置是p,那么从p和链的起始s，同时前进，相遇的位置即为环开始的地方，走过的长度即为连接环的链长。

SRM 661 Div1 Med
n<=10^12个点，每个点k<=10^12种可涂的颜色。每个点i可以向j(j < i)连边，问图的不同方案数mod m(m<=10^6)。
Solution：
直接dp。m较小，按照mod值分类。

SRM 663 Div2 Hard
n(n<=16 and will be power of 2)个人比赛，每两个人一组，胜者继续。问最后每个人分别有多少种方案数可以赢。
Solution：
dp[i,j]表示集合i包含的人当中j胜出的方案数。

SRM 664 Div1 Med
n(n<=10^6)个顶点的一棵树，对每个顶点攻击一次。攻击之后保留这个点的概率是1/(i+1)，i/(i+1)的概率这个点以及联通它的边消失。
设攻击完之后剩余联通分量顶点个数分别为n1,n2...nk。求n1^2+n2^2+...+nk^2的期望*N!之后mod 1e9+7。
Solution：
(a+b)^2=a^2+b^2+a*b+b*a。实际是两两相乘。
那么nk^2实际上可以转化成联通分量里联通的顶点pair(u, v)的对数。这样就可以对每一个pair计数概率。dp[u]表示以u为根的子树中，含u的pair出现的概率。
generate法则保证儿子的标号大于父亲的标号，因此从大到小枚举即可。

SRM 666 Div1 Med
对于n(n<=4000)个数的排列，按照排列各个位置上数字去放东西。比如(p1, p2, p3)=(1,3,2)，那么先在1上放一个，再在3上放一个，最后在2上放一个。
每次放的时候给结果乘以一个(n-x)其中x为当前放的位置的左右两边已经有的东西的个数。然后求所有排列的这个值的和。
Solution：
dp[i]表示前i个数的排列的和，那么第i + 1个数可以放在两端，也可以放在中间。

SRM 669 Div1 Med
n(n<=200)个点的完全图，每条边边权是[1,l(l<=200)]。对于l^(n*(n-1)/2)种图中的每一个，count线型生成树的个数，然后对所有图加和。问和是多少。
Solution：
dp[i,j]表示前i条边，线型MST上最大色为j时的方案数。这里要枚举第一条最大的边是哪一条(比如为k)，
然后将这i个点分成了两个部分，前k-1条边最大色为j - 1，后面i-k条边上的最大色则为j。然后跨两部分的边的可选色为l-j+1，则转移为:
dp[i,j]=dp[k,j-1]*dp[i-k,j]*((l-j+1)^((k-1)*(i-k)))。

SRM 672 Div1 Med
求n(n<=2000)个点(无自环无重边无向图)的近欧拉图有多少种，结果mod 1e9+7。近欧拉图包括欧拉图＋加一条边/减一条边能变成欧拉图的图。
Solution：
由近欧拉图得到欧拉图，图中有不超过一对奇度点，连接or删掉这对点之间的边即可。因此每一个欧拉图对应n(n-1)/2+1个近欧拉图。
设n个点欧拉图方案数为E。欧拉图定义为：每个点degree为偶数且联通。那么我们可以求出degree全为偶数的图的方案数(设为D)再减掉不联通的那些(设为R)。
对于D，每一个n-1个顶点的图都对应一个n顶点的degree全偶的图(第n个点补上缺掉的degree就行)，因此方案数2^((n-1)*(n-2)/2)。
对于R，如果不联通必然包含多个联通分量。假设1所在的分量有k个点，那么就有C(n-1,k-1)*(Dk-Rk)*Dn-k。因此E=D-R，求出即可。

SRM 673 Div1 Med
求1-n(n<=100)的每个排列所对应的Cartesian树中得分<=s(s<=100)的方案数。
Cartesian树定义：小根堆二叉树，中序遍历此树能得到对应排列。
得分计算方法：对于树中有两个儿子的顶点，找出两个儿子在原排列中的对应下标差，sum up所有这样的值。
Solution：
dp[i,j]表示i个数和为j的方案数。转移的时候枚举左边根下标idx1和s1，右边根下标idx2和s2。
那么可以预处理出sum[s1+abs(k-idx1)]和sum[s2+abs(k-idx2)]，其中k为i个数中的根的下标(即i个数中的最小值)。
