SRM 644 Div1 Med
N=10^15个人，进行K<=6轮比赛。每轮将现有人数分成R个room，每个room人数不少于2。每个room一人胜出，进行下一轮room划分和比赛。最终K轮之后至少1人胜出。
问room划分总方案数。
Solution:
给N个叶节点，组成一棵K层的树，使得除了叶节点以外每个节点儿子数>=2。问构造方案数。
由于6比较小，6!又不可能。。。考虑2^6的算法。。。
假设我们从左到右把叶子节点加进来，那么当前刚加入的叶子节点和总的root之间的这条路径以左的非叶节点必然已经满足儿子数>=2的条件了。
那么就看这条路径上的节点的状态。用0表示儿子数为1，用1表示儿子数>=2。就可以得到2^6的状态了。
转移的时候，从最低位到最高位，第一个0以及比它低位的所有1都可以作为新的分叉点。
比如10111可以转移到10111, 10110, 10100, 11000。
于是我们得到2^6 * 2^6的转移矩阵。之后用矩阵快速幂求即可。
需要注意的是，因为最终可能不止一人胜出。于是要加一个虚拟根节点变成k + 1层。
而取解的时候变成同时取出res[(1<<K) - 1][0] + res[(1<<(K + 1)) - 1][0]即可。

SRM 647 Div1 Med
n<=500个机器人，价钱cost油量cap，从原点出发向右运动，每秒钟耗费1unit油。
每个时刻每个机器人可以选择反向回去，保证油量能返回原点的情况下剩余油量送给下一个机器人。
有总钱数B<=10000，买一些机器人，要使得最后剩下的机器人走得最远。问有多远。
Solution：
假设已经买定一个set的机器人，如何最远？首先一定是cap小的把油给cap大的。设capA < capB,t时刻后返回，那么送出的油量是min(capA-2t, t)。
画图分析，极值点取在capA/3处。那么这两个可以合并成capB + capA/3。多个的以此类推。至于买哪些，直接dp即可。

SRM 647 Div2 Hard
给10^9个building设定高度，满足building[1]=0，相邻两个building高度delta<=k(k<=10^9)，所有高度非负数。
且满足，给定x(size<=500)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
不能枚举最大高度是哪个，但是可以二分最大高度是多少。对于一对(x,t)，二分的最大高度是h，那么h和x的距离d>=(h-t-1)/k。
因此有非法区间[max(1,x-d),min(x+d,n)]。取所有非法区间的并集，看补集是否为空。

SRM 652 Div1 Med
n<=1000个点，m<=2500条边的有向图。每条边上有个cost。A想尽量快地从0到n－1，B有k<=1000个token，想尽量阻止A到达n-1，如果不能，就让A尽量晚到。
每次A会告诉B她要走的边，B可以选择使用token改变A要走的边，也可以选择不使用。问双方都最优策略，A多久到n－1。
Solution：
dp[i,j]表示在i节点，已经使用了j张token要到达n-1所要花费的最小cost。
那么在i节点，A要选择的是所有临接节点里面dp[k,j]最小的，而B要选择的是所有dp[k,j+1]里面最大的。然后从n节点倒着dp回0节点即可。
几个技巧：
1）可以以k划分阶段，滚动优化。
2）每次可以预处理出B的选择，以便在i+1时可以直接用。

SRM 655 Div1 Med
5000个位置填[0,9]的数字，N=5个问题。每个数字对应一个mask，表示这个数字会出现在第几个问题里。
对于每个问题，按顺序读会出现的数字之后会组成一个十进制数，问所有N个问题得到的十进制数mod9都为0的方案数。
Solution:
注意到每个数字只会影响mask所包含这几个问题的结果，那么可以按照这个mask把数字归类，统计这一类中各位数字mod9的结果，先dp预处理出来。
然后把每个mask对应的结果放到总的结果里。
然后这个实现的时候还有个点，添加每个mask对应结果的时候，按照mask从小到大正常地状压dp就可以了。
