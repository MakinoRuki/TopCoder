SRM 644 Div1 Med
N=10^15个人，进行K<=6轮比赛。每轮将现有人数分成R个room，每个room人数不少于2。每个room一人胜出，进行下一轮room划分和比赛。最终K轮之后至少1人胜出。
问room划分总方案数。
Solution:
给N个叶节点，组成一棵K层的树，使得除了叶节点以外每个节点儿子数>=2。问构造方案数。
由于6比较小，6!又不可能。。。考虑2^6的算法。。。
假设我们从左到右把叶子节点加进来，那么当前刚加入的叶子节点和总的root之间的这条路径以左的非叶节点必然已经满足儿子数>=2的条件了。
那么就看这条路径上的节点的状态。用0表示儿子数为1，用1表示儿子数>=2。就可以得到2^6的状态了。
转移的时候，从最低位到最高位，第一个0以及比它低位的所有1都可以作为新的分叉点。
比如10111可以转移到10111, 10110, 10100, 11000。
于是我们得到2^6 * 2^6的转移矩阵。之后用矩阵快速幂求即可。
需要注意的是，因为最终可能不止一人胜出。于是要加一个虚拟根节点变成k + 1层。
而取解的时候变成同时取出res[(1<<K) - 1][0] + res[(1<<(K + 1)) - 1][0]即可。

SRM 647 Div1 Med
n<=500个机器人，价钱cost油量cap，从原点出发向右运动，每秒钟耗费1unit油。
每个时刻每个机器人可以选择反向回去，保证油量能返回原点的情况下剩余油量送给下一个机器人。
有总钱数B<=10000，买一些机器人，要使得最后剩下的机器人走得最远。问有多远。
Solution：
假设已经买定一个set的机器人，如何最远？首先一定是cap小的把油给cap大的。设capA < capB,t时刻后返回，那么送出的油量是min(capA-2t, t)。
画图分析，极值点取在capA/3处。那么这两个可以合并成capB + capA/3。多个的以此类推。至于买哪些，直接dp即可。

SRM 647 Div2 Hard
给10^9个building设定高度，满足building[1]=0，相邻两个building高度delta<=k(k<=10^9)，所有高度非负数。
且满足，给定x(size<=500)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
不能枚举最大高度是哪个，但是可以二分最大高度是多少。对于一对(x,t)，二分的最大高度是h，那么h和x的距离d>=(h-t-1)/k。
因此有非法区间[max(1,x-d),min(x+d,n)]。取所有非法区间的并集，看补集是否为空。

SRM 652 Div1 Med
n<=1000个点，m<=2500条边的有向图。每条边上有个cost。A想尽量快地从0到n－1，B有k<=1000个token，想尽量阻止A到达n-1，如果不能，就让A尽量晚到。
每次A会告诉B她要走的边，B可以选择使用token改变A要走的边，也可以选择不使用。问双方都最优策略，A多久到n－1。
Solution：
dp[i,j]表示在i节点，已经使用了j张token要到达n-1所要花费的最小cost。
那么在i节点，A要选择的是所有临接节点里面dp[k,j]最小的，而B要选择的是所有dp[k,j+1]里面最大的。然后从n节点倒着dp回0节点即可。
几个技巧：
1）可以以k划分阶段，滚动优化。
2）每次可以预处理出B的选择，以便在i+1时可以直接用。

SRM 655 Div1 Med
5000个位置填[0,9]的数字，N=5个问题。每个数字对应一个mask，表示这个数字会出现在第几个问题里。
对于每个问题，按顺序读会出现的数字之后会组成一个十进制数，问所有N个问题得到的十进制数mod9都为0的方案数。
Solution:
注意到每个数字只会影响mask所包含这几个问题的结果，那么可以按照这个mask把数字归类，统计这一类中各位数字mod9的结果，先dp预处理出来。
然后把每个mask对应的结果放到总的结果里。
然后这个实现的时候还有个点，添加每个mask对应结果的时候，按照mask从小到大正常地状压dp就可以了。

SRM 656 Div2 Hard
有多少1-n(n<=200)的排列满足当且仅当下标idx在给定数组pos(size<=200)时，p[idx]<p[idx+1]。答案mod 1e9+7。
Solution:考察折线的每个极小值点。用dp[i,j]表示[i,j]的方案数，那么j-i+1个数的最小值必然是放在极小值。
然后可以分成两段。dp[i,j]=dp[i,k-1]*dp[k+1,j]*C(j-i+1,k-i)。

SRM 658 Div1 Med
有n<=20个敌军，每人血量<=60。每次可以开一枪，选一个人掉血9，一个人6，一个人3。三者不能是同一个人。问杀死所有人最少开多少枪。
Solution：
二分开枪数m。dp[i,n9,n3]表示前i个SCV用了n9个9和n3个3消耗的最少的1的个数。枚举时满足条件对一个敌军，n1+n3+n9<=m。

SRM 660 Div1 Med
n<=50个人，每个人有个讨厌的人。随机地邀请这些人，如果他讨厌的人没来他就来。问来人数的期望。
Solution：
分情况讨论。
先看链。只跟长度有关。枚举去掉哪个点，dp。
看环。去掉一个点，转成链。
看带链的环。去掉链上的点好说；去掉环上的点会变成“Y”字形。设三条arm分别为a,b,c，那么根据独立性，这个“Y"字形的答案就是f(a + c) + f(b + c) - f(c)。
综上所述，对于一个点，如果是在环上，求环的期望，又因为环上每个点的对称性，除以环长得出每个点的概率；
如果在链上，求它距离环的距离，设为d，连接的环长为r，根据独立性，那么答案就是f[d][r] - f[d - 1][r]。
找环的时候这个“追击”的方法竟然是floyd发明的？！
确定连接环的链长，方法是，找到环的时候两者相遇在环上的位置是p,那么从p和链的起始s，同时前进，相遇的位置即为环开始的地方，走过的长度即为连接环的链长。

SRM 661 Div1 Med
n<=10^12个点，每个点k<=10^12种可涂的颜色。每个点i可以向j(j < i)连边，问图的不同方案数mod m(m<=10^6)。
Solution：
直接dp。m较小，按照mod值分类。

SRM 663 Div2 Hard
n(n<=16 and will be power of 2)个人比赛，每两个人一组，胜者继续。问最后每个人分别有多少种方案数可以赢。
Solution：
dp[i,j]表示集合i包含的人当中j胜出的方案数。

SRM 664 Div1 Med
n(n<=10^6)个顶点的一棵树，对每个顶点攻击一次。攻击之后保留这个点的概率是1/(i+1)，i/(i+1)的概率这个点以及联通它的边消失。
设攻击完之后剩余联通分量顶点个数分别为n1,n2...nk。求n1^2+n2^2+...+nk^2的期望*N!之后mod 1e9+7。
Solution：
(a+b)^2=a^2+b^2+a*b+b*a。实际是两两相乘。
那么nk^2实际上可以转化成联通分量里联通的顶点pair(u, v)的对数。这样就可以对每一个pair计数概率。dp[u]表示以u为根的子树中，含u的pair出现的概率。
generate法则保证儿子的标号大于父亲的标号，因此从大到小枚举即可。

SRM 666 Div1 Med
对于n(n<=4000)个数的排列，按照排列各个位置上数字去放东西。比如(p1, p2, p3)=(1,3,2)，那么先在1上放一个，再在3上放一个，最后在2上放一个。
每次放的时候给结果乘以一个(n-x)其中x为当前放的位置的左右两边已经有的东西的个数。然后求所有排列的这个值的和。
Solution：
dp[i]表示前i个数的排列的和，那么第i + 1个数可以放在两端，也可以放在中间。

SRM 669 Div1 Med
n(n<=200)个点的完全图，每条边边权是[1,l(l<=200)]。对于l^(n*(n-1)/2)种图中的每一个，count线型生成树的个数，然后对所有图加和。问和是多少。
Solution：
dp[i,j]表示前i条边，线型MST上最大色为j时的方案数。这里要枚举第一条最大的边是哪一条(比如为k)，
然后将这i个点分成了两个部分，前k-1条边最大色为j - 1，后面i-k条边上的最大色则为j。然后跨两部分的边的可选色为l-j+1，则转移为:
dp[i,j]=dp[k,j-1]*dp[i-k,j]*((l-j+1)^((k-1)*(i-k)))。

SRM 672 Div1 Med
求n(n<=2000)个点(无自环无重边无向图)的近欧拉图有多少种，结果mod 1e9+7。近欧拉图包括欧拉图＋加一条边/减一条边能变成欧拉图的图。
Solution：
由近欧拉图得到欧拉图，图中有不超过一对奇度点，连接or删掉这对点之间的边即可。因此每一个欧拉图对应n(n-1)/2+1个近欧拉图。
设n个点欧拉图方案数为E。欧拉图定义为：每个点degree为偶数且联通。那么我们可以求出degree全为偶数的图的方案数(设为D)再减掉不联通的那些(设为R)。
对于D，每一个n-1个顶点的图都对应一个n顶点的degree全偶的图(第n个点补上缺掉的degree就行)，因此方案数2^((n-1)*(n-2)/2)。
对于R，如果不联通必然包含多个联通分量。假设1所在的分量有k个点，那么就有C(n-1,k-1)*(Dk-Rk)*Dn-k。因此E=D-R，求出即可。

SRM 673 Div1 Med
求1-n(n<=100)的每个排列所对应的Cartesian树中得分<=s(s<=100)的方案数。
Cartesian树定义：小根堆二叉树，中序遍历此树能得到对应排列。
得分计算方法：对于树中有两个儿子的顶点，找出两个儿子在原排列中的对应下标差，sum up所有这样的值。
Solution：
dp[i,j]表示i个数和为j的方案数。转移的时候枚举左边根下标idx1和s1，右边根下标idx2和s2。
那么可以预处理出sum[s1+abs(k-idx1)]和sum[s2+abs(k-idx2)]，其中k为i个数中的根的下标(即i个数中的最小值)。

SRM 675 Div1 Hard
问能否构造出n(n<=50)个顶点和exactly有s(s<=1000)条长度为2的path的树。
Solution：
直接dp。dp[i,j,k]表示i个点有j个叶子长度为2的path条数为k是否可能。

SRM 677 Div1 Med(🌲dp)

SRM 684 Div1 Med
n(n<=50000)个数的sequence，每个数在1到k(k<=50000)范围内。问有多少符合条件的序列。条件：对i,a[i]<=a[i+1] or a[i] % a[i+1] != 0。
Solution：容斥思想。good(n)=k^n-bad(n)。
bad(n)=bad(n-1)*k + good(n-2)*seq(2)。其中seq(2)是a[i]%a[i+1]=0的pair。
然而，当我们把pair加到末尾的时候可能会导致good(n-2)中的最后一个和加进来的第一个数组成bad pair，因此要-good(n-3)*seq(3)。这样只要一直容斥就可以了。
另外seq的长度因为是指数增长，因此不会超过log2(k)。对于seq直接dp计数即可。

SRM 686 Div2 Hard
n(n<=100)个"("和")"的括号序列，问不同的非空合法括号序列有多少种。
Solution：
dp[i,j]表示前i个位置多余j个"("的序列方案数。那么枚举下一个的时候，关键不是位置，而是是"("还是")"。因此就枚举是"("还是")"，
相应地选择第一个出现的位置转移即可。

SRM 690 Div1 Med
n(n<=10^5)个顶点的无向🌳，给每条边加个方向得到一个有向图。对于这个有向图求出有多少unordered pair(x,y)使得x->y有一条路径。
求所有2^(n-1)这样的有向图的unordered pair和。
Solution：
每条长度为k的路径贡献2^(n-1-k)=2^(n-1) / 2^k。那么dp路径，每次加一条边就乘一次2^(-1)。

SRM 690 Div2 Hard
在2*n(n<=1000)的格子上安排0-2*n-1的🐺站位。问有多少种满足条件的方案。
条件：1）每一行至少有一个编号>=k的🐺；2）按顺序写出每一列的编号较大值和每一行编号最大值得到n+2的序列，序列不同则为不同方案。
Solution：
首先关注行的最大值可以取多少。假设和2n-1放在同一行的数是[2n-1, m]，而第一个和2n-m中的某一个数放在同一列的是m-1，那么两行的最大值的不同组合
是2*(2n-m-1)(特别地，m<=k的时候只能取到2*(2n-k-1))。剩下的就是要求列的较大值的组合情况。可以直接dp。
dp[i,j]表示当前要放1-i的数字，而和2n-1在同一行的位置还有j个，列的不同较大值组合的方案数。那么对于i，可以把它塞到和[i+1, 2n-1]同一列，
也可以让它新开一列，成为某一列的较大值。最后列的结果乘上n!再乘上行的最大值的方案数即可。

SRM 693 Div1 Easy
n(n<=100)个顶点，对于每个i,i+1有一条权值为w1[i]的边，对于每个i,i+2有一条权值为w2[i]的边。问从图中删掉权值和最大的边，使得剩下的图为
2-edge connected，则剩下的边权值总和最小多少。
2-edge connected定义：任意一对顶点之间至少有两条不相交的路径。
Solution：
最后结果应该是一些环相互连接。如果有6个点，那么最后会是类似于0-1-2-0+2-4-5-3-2这样。设每个点有三种状态，即作为环的起点，终点和中间节点。
那么dp[i,j]就表示第i个点状态为j时候的最小边权和。之后转移。

SRM 694 Div1 Med
n(n<=1000)个人，m(m<=20)个问题，mat[i,j]=['A','Z']。问能把所有人区分开来的问题集合有多少个。
Solution：
预处理出任意两个人的答案相同的问题集合，则这个问题集合以及这个集合的子集是不可以的。状压dp从大到小推。

SRM 696 Div1 Easy
50个点的图，有m(m<=20)条无向边。要给所有点涂色，每次涂色花费是所有两端点都已被涂的边条数和。问最小代价。
Solution：
状压dp。dp[i]表示边集i被选进来的代价。枚举去掉某一条边的某个顶点，则去掉这个顶点的所有临接边的边集j，由dp[i^j]转移到dp[i]。

SRM 696 Div2 Hard
n(n<=20)个顶点个无向图，给出边的邻接矩阵，最多m(m<=20)组关系缺失。问2^m种不同的图，各自求最大团之后加和是多少。
Solution：
枚举每个顶点集合，求出使这个顶点集合x为最大团所必要的缺失边集合s，则更新dp[s]=max(dp[s],x)。
之后枚举缺失边i得到s的超集(s|(1<<i))，更新dp[s|(1<<i)]=max(dp[s|(1<<i)],dp[s])。

SRM 697 Div2 Hard
n(n<=1000)个选手参加2^m(m<=30)天比赛，每个选手有个a[i](0<=a[i]<2^m)能力值，第j天比赛时，把所有人的a[i]和j异或，按照从小到大排序。
每个人得分排名的平方。求每个人2^m天得分总和mod 1e9+7之后的和。
Solution:
对每个人算出排名第x的方案数。dp[b,r]表示在考察a[i]的第b位，排名第r位的方案数。然后枚举第b位是0/1转移。

SRM 698 Div2 Hard 🌲🌳🌴
n(n<=50)个点的一颗无向树，每个顶点有个权值。问每一棵子树上所有顶点权值求or之后得到的值的和是多少。
Solution：
拆位＋求补集。对于每一位，求出or之后含这一位的子树有多少。可以用补集，即求出or之后不含这一位的子树有多少。dp[b,i]表示经过顶点i的，or的结果不含第b位的
子树总数。

SRM 701 Div1 Med
长度为n(n<=50)的string，对于每个0<i<2^n，从小到大扫i的每一位b，如果b是1的话就把s的最后b+1个字符翻转，最终扫完得到一个t。对于所有的t的集合，
找到字典序第k小的string。
Solution：
对于每一位从a到z枚举，然后dp出与当前前缀match的string方案数。注意到这个集合生成方式实际上就是，从0到n-1地枚举s的每一位，
选择把这一位从外往里地加入到t的两侧。比如t的前缀为i，后缀为j，那么s的第i+j+1个字符就可以加到前面的第i+1个和倒数的第j+1个。
因此dp[i,j]表示用了s的前i个字符，其中前缀长度为j的方案数。那么第i+1个字符可以放到j+1或者n-(i-j)个位置，但是要注意与前面枚举的前缀match。

SRM 702 Div1 Med
问长度为n(n<=150)的string，good的子序列排第k大的是谁。good定义：()或者(SSS),其中S为good string。
Solution：
首先dp出来长度为x的good string方案数，发现总数并不多(total 9526 when n <= 150)。然后暴力生成暴力check是否匹配即可。

SRM 703 Div1 Med

SRM 704 Div2 Hard
长度为n(n<=10^9)的序列，每个数[0,k)(k<=100)。问多少序列满足乘积mod k = v。结果mod 1e9+7。
Solution：
快速矩阵幂。构造一个矩阵满足a[i][j]是前面mod k = i时，再乘一个数转移到j的方案数。

SRM 603 Div1 Med
问有多少合法的串对(A,B)满足，|A|=|B|=n(n<=10^9)且AB中的字符均属于前k个小写字母且存在一个C满足A+C=C+B。
Solution：
首先满足条件的A和B必然是形如(x+y,y+x)的形式，即B是A的一个rotation。那么看一个A会有多少个不同的rotation，这取决于A中最长的循环节长度。
对于循环节长度为d的A，方案数有f[d]*d。那么可以dp这个f[d]，但是要注意减掉d' < d && d' | d的f[d']。最终求出g[d]，即以d为最长循环节的串的方案数。

SRM 604 Div1 Med
