SRM 647 Div1 Easy
给10^5个building设定高度，满足building[1]=0，相邻两个building高度delta<=1，所有高度非负数。
且满足，给定x(size<=50)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
枚举最大高度是哪个，然后check能否满足每一对(x,t)。

SRM 649 Div1 Easy
给一个长度为50的大写字母字符串，现在要扣掉K个，问扣掉之后给你新串和原串，问你是否能猜出是扣掉了哪些位置。
Solution:
只要看相同的字母，它们之间的距离是否<=k即可。

SRM 649 Div1 Med
给一个10^5的数组A，每个数都在[0, 2^30)之内。让你选一个B∈[0, 2^30)，跟A的每一个元素异或，得到C数组。
要使得C数组中(i < j && C[i] < C[j])的pair之和最大。
Solution:
拆位来看。
对于某一位，我们把n个数的这一位都取出来，得到一个01序列。
那么要求的pair数理应为这个01序列的pair数+这一位为0的所有数组成新序列的pair数+这一位为1的所有数组成新序列的pair数。之后递归求解。

SRM 655 Div1 Easy
20*20的全W矩阵init。每次可以选择一块k*k的区域全涂黑或者全涂白。问最后是否能达到给定矩阵tar。
Solution：
最后一次涂过之后肯定剩下了一块k*k的纯色矩阵。那么每次试图找这样一块k*k纯色(或有待定色x)矩阵，里面的内容全部换成待定色x。
这样最后如果剩下整个n*n只有纯白或者待定色x，那么就是OK的。

SRM 665 Div1 Med
n(n<=500)顶帽子按某顺序排放，每顶i上写了一个正整数x和一个正整数y。其中y要么等于i以及i之前所有帽子上x的和，要么等于i以及i以后所有帽子上x的和。
给定x的数组A和y的数组B，问有多少种不同的AB数组和帽子的对应关系。
Solution：
首先考察可以发现(sum[i] == value[i] || sum[i] == total sum)的应该有且仅有两个。那么就先把这两个放在两端。
在放第三个的时候，从目前较小的一端开始。可以发现满足(value[i] + X == sum[i] || total sum - X = sum[i])的可以放在这里的hat，
只有在两端相等的时候有两个，其余情况有且只有一个。因此要么乘以2，要么什么也不做。

SRM 668 Div1 Easy
r(r<=50)*c(c<=50)的格子，问是否能从某个格子出发不重不漏地遍历每个格子k(k<=50)次。
Solution：
R*C是偶数时都有解，是奇数时只有K==1才有解。
原因的话，从此出发能遍历所有格子的点，和不能遍历的点是相邻的。也就是说一个能遍历的点周围都是不能遍历的点。
相当于黑白染色，从黑格子出发可以回到黑格子；然而从白格子出发要回到白格子则路径长度不够R*C。

SRM 669 Div1 Easy
长度为S(S<=1000)的长条，每次选一段切一刀。切下去之后得到长度为x和y的两段，则得分为x*y。问使得得分>=M最少切多少刀。
Solution：
假设来k个round，那么最终分成k + 1段。比如k = 2, 代价则为x=a1*(n-a1) + a2*(n-a2) + a3*(n- a3)。那么x/2 >= M的话，k就是解了。
要使x最大，则几段尽量均分即可。

SRM 669 Div2 Hard
n(n<=16)个点的完全图，每条边边权是1or2。对于2^(n*(n-1)/2)种图中的每一个，count线型生成树的个数，然后对所有图加和。问和是多少。
Solution：
2^(n-1)枚举每条边的边权。然后对于一个生成line计算出可以出现在多少个完全图中。每加一条边，形成的环中原先line上的边最大值不能超过新加的边。
因此暴力计数check即可。最后再乘以n!/2。

SRM 674 Div1 Med
n(n<=200000)辆车在一个无穷坐标轴上，每辆车有个初始方向。每辆车每秒走1个单位，两辆车碰到之后会以原速度都反向。
给出q(q<=200000)个询问，求t[i]时刻car[i]与0点的距离差。
Solution：
🍎蚂蚁系列进阶。🍏
1）蚂蚁相碰可以看作方向没变，穿过之后继续前进。
2）蚂蚁相碰之后相对位置不会改变，原先排第几现在还排第几。
3）对于本题，每次相当于是求t[i]秒之后位移排在第car[i]的点是谁。
也就是从一堆坐标中找第k大点的坐标。那么可以二分这个坐标，check有多少<=二分得到的坐标值的。

SRM 675 Div1 Med
使用x[i] = (x[i - 1] * a + b) % 1000000007的式子产生5000000个数字，100个query询问第k大的数字求和。但是内存要求每次只能使用260000个int。
Solution:
分段的思想。设置一个delta=30000。按照x[i]/delta的结果分段。统计一段中有多少个数字。
query的时候先查看k是在第几段，然后在这一段中按照x[i]%delta继续分组。找到第几组，也就是结果%delta的余数是多少。确定答案。

SRM 680 Div1 Med
构造一个n(n<=1000)个点m(m<=1000)条边的无向图，使得找MST的算法A在这个图上跑k(k<=1000)次刚好能找出MST。无解返回-1。
算法A:算法每趟跑时，对于图中的每一个联通分量找一条只有一个顶点在这个分量里的最小边，然后把找到的所有这样的边加到MST的边集里。
Solution：
最慢的生成方式是每次消去一半的联通分量(两两连接)。这样进行k-1次，剩下所有的联通分量在最后一轮(第k轮)连到一起。不够m条边就在没连起来的pair上连起来。

SRM 681 Div1 Easy
每辆飞船有m(m<=10^5)个part，n(n<=50)个工厂去制造它们。每个工厂可以制造a[i]到b[i]之间的k[i]个part，问最多能造多少艘船。
Solution：
可以二分答案。check的时候工厂按照a[i]排序。从小到大枚举part编号，每个part枚举到的时候，a[i]<=part的工厂都加进set，加进来之后按照b[i]从小到大消耗。

SRM 681 Div1 Med
n(n<=10^7)个数字，在内存只有1M情况下找出每个数字的半径求和。半径定义：i-k>=0 && i+k < n && x[i]大于[i-k,i+k]中除了x[i]之外的所有数。
数列生成方法：x[0]=x0, for (i:1->n-1) x[i]=(x[i-1]^a+b)&(1<<50 - 1)。
Solution：
既然不能全部算好load进来，那么就online地处理。由x[i]得到x[i-1]的方法：((x[i]+(1<<50)-b)^a)&(1<<50 - 1)。
然后暴力地扫每个数字就行了。因为按照x[i]从大到小来看，实际上会分成很多段，那么扫到的数字的次数是nlogn的。

SRM 682 Div1 Med
n(n<=50)个点n(n<=50)条边的无向联通图，通过每次选两个点合并来达到最终局面：存在一个点，任意一对顶点之间的路径都要经过这个点。问最少合并次数。
Solution：
首先环一定要合并起来，然后非叶节点也要合并到一起。但是有个坑：就是在环上存在degree=2的点的时候可以少合并一次(因为合并完后这个点就会变成叶子。)

SRM 688 Div1 Easy
n(n<=1000)的小括号序列，每次可以选一段[L,R]把它们翻转，问不超过10次翻转能否把这个序列变成合法序列。
Solution：
遇到括号匹配的问题如果不是dp或者搜索，可以多考虑stack。
因为被反转序列中已经合法的括号子序列可以被无视，因此stack维护出来之后只剩")))...(((..."or")))..."or"(((..."这种。之后可以直接搞。
