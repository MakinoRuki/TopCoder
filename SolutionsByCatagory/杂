SRM 607 Div1 Med
一排n(n<=2500)个转轮，每个转轮上面刻了一圈0-9的数字，每次可以选一个连续区间，把这个区间里的轮同时向上转1或者向下转1。
问从初始状态S转到目标状态T最少转多少次。
Solution：
首先重写一下条件。要把S调到T，实际上就是要把delta(S-T)调到0。那么变成000...000也就意味着相邻两项之间的差值%10=0。
因此可以考察R[i]=(S[i]-T[i])%10的相邻两项之间的关系，我们设这个delta为S[i]=R[i] - R[i - 1],S[0]=R[0]。那么对于R的操作可以转化成对于S的操作。
如果是选一段[i,j]加1，实际是S[i]+1,S[j] - 1。减同理。如果是从i到结尾加1，则是S[i]+1，其余不变。减同理。
则，每次调整要么选两个S[i]配对加减，要么单个加减。
那么就可以把S排序，小的数向下调到0，大的数向上调到10。那么怎么定义是大还是小呢。排序之后枚举分界点即可。
kmjp说：为什么我不dp呢。因为这题是475pt啊。致敬。

SRM 647 Div1 Easy
给10^5个building设定高度，满足building[1]=0，相邻两个building高度delta<=1，所有高度非负数。
且满足，给定x(size<=50)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
枚举最大高度是哪个，然后check能否满足每一对(x,t)。

SRM 649 Div1 Easy
给一个长度为50的大写字母字符串，现在要扣掉K个，问扣掉之后给你新串和原串，问你是否能猜出是扣掉了哪些位置。
Solution:
只要看相同的字母，它们之间的距离是否<=k即可。

SRM 649 Div1 Med
给一个10^5的数组A，每个数都在[0, 2^30)之内。让你选一个B∈[0, 2^30)，跟A的每一个元素异或，得到C数组。
要使得C数组中(i < j && C[i] < C[j])的pair之和最大。
Solution:
拆位来看。
对于某一位，我们把n个数的这一位都取出来，得到一个01序列。
那么要求的pair数理应为这个01序列的pair数+这一位为0的所有数组成新序列的pair数+这一位为1的所有数组成新序列的pair数。之后递归求解。

SRM 655 Div1 Easy
20*20的全W矩阵init。每次可以选择一块k*k的区域全涂黑或者全涂白。问最后是否能达到给定矩阵tar。
Solution：
最后一次涂过之后肯定剩下了一块k*k的纯色矩阵。那么每次试图找这样一块k*k纯色(或有待定色x)矩阵，里面的内容全部换成待定色x。
这样最后如果剩下整个n*n只有纯白或者待定色x，那么就是OK的。

SRM 665 Div1 Med
n(n<=500)顶帽子按某顺序排放，每顶i上写了一个正整数x和一个正整数y。其中y要么等于i以及i之前所有帽子上x的和，要么等于i以及i以后所有帽子上x的和。
给定x的数组A和y的数组B，问有多少种不同的AB数组和帽子的对应关系。
Solution：
首先考察可以发现(sum[i] == value[i] || sum[i] == total sum)的应该有且仅有两个。那么就先把这两个放在两端。
在放第三个的时候，从目前较小的一端开始。可以发现满足(value[i] + X == sum[i] || total sum - X = sum[i])的可以放在这里的hat，
只有在两端相等的时候有两个，其余情况有且只有一个。因此要么乘以2，要么什么也不做。

SRM 668 Div1 Easy
r(r<=50)*c(c<=50)的格子，问是否能从某个格子出发不重不漏地遍历每个格子k(k<=50)次。
Solution：
R*C是偶数时都有解，是奇数时只有K==1才有解。
原因的话，从此出发能遍历所有格子的点，和不能遍历的点是相邻的。也就是说一个能遍历的点周围都是不能遍历的点。
相当于黑白染色，从黑格子出发可以回到黑格子；然而从白格子出发要回到白格子则路径长度不够R*C。

SRM 669 Div1 Easy
长度为S(S<=1000)的长条，每次选一段切一刀。切下去之后得到长度为x和y的两段，则得分为x*y。问使得得分>=M最少切多少刀。
Solution：
假设来k个round，那么最终分成k + 1段。比如k = 2, 代价则为x=a1*(n-a1) + a2*(n-a2) + a3*(n- a3)。那么x/2 >= M的话，k就是解了。
要使x最大，则几段尽量均分即可。

SRM 669 Div2 Hard
n(n<=16)个点的完全图，每条边边权是1or2。对于2^(n*(n-1)/2)种图中的每一个，count线型生成树的个数，然后对所有图加和。问和是多少。
Solution：
2^(n-1)枚举每条边的边权。然后对于一个生成line计算出可以出现在多少个完全图中。每加一条边，形成的环中原先line上的边最大值不能超过新加的边。
因此暴力计数check即可。最后再乘以n!/2。

SRM 674 Div1 Med
n(n<=200000)辆车在一个无穷坐标轴上，每辆车有个初始方向。每辆车每秒走1个单位，两辆车碰到之后会以原速度都反向。
给出q(q<=200000)个询问，求t[i]时刻car[i]与0点的距离差。
Solution：
🍎蚂蚁系列进阶。🍏
1）蚂蚁相碰可以看作方向没变，穿过之后继续前进。
2）蚂蚁相碰之后相对位置不会改变，原先排第几现在还排第几。
3）对于本题，每次相当于是求t[i]秒之后位移排在第car[i]的点是谁。
也就是从一堆坐标中找第k大点的坐标。那么可以二分这个坐标，check有多少<=二分得到的坐标值的。

SRM 675 Div1 Med
使用x[i] = (x[i - 1] * a + b) % 1000000007的式子产生5000000个数字，100个query询问第k大的数字求和。但是内存要求每次只能使用260000个int。
Solution:
分段的思想。设置一个delta=30000。按照x[i]/delta的结果分段。统计一段中有多少个数字。
query的时候先查看k是在第几段，然后在这一段中按照x[i]%delta继续分组。找到第几组，也就是结果%delta的余数是多少。确定答案。

SRM 680 Div1 Med
构造一个n(n<=1000)个点m(m<=1000)条边的无向图，使得找MST的算法A在这个图上跑k(k<=1000)次刚好能找出MST。无解返回-1。
算法A:算法每趟跑时，对于图中的每一个联通分量找一条只有一个顶点在这个分量里的最小边，然后把找到的所有这样的边加到MST的边集里。
Solution：
最慢的生成方式是每次消去一半的联通分量(两两连接)。这样进行k-1次，剩下所有的联通分量在最后一轮(第k轮)连到一起。不够m条边就在没连起来的pair上连起来。

SRM 681 Div1 Easy
每辆飞船有m(m<=10^5)个part，n(n<=50)个工厂去制造它们。每个工厂可以制造a[i]到b[i]之间的k[i]个part，问最多能造多少艘船。
Solution：
可以二分答案。check的时候工厂按照a[i]排序。从小到大枚举part编号，每个part枚举到的时候，a[i]<=part的工厂都加进set，加进来之后按照b[i]从小到大消耗。

SRM 681 Div1 Med
n(n<=10^7)个数字，在内存只有1M情况下找出每个数字的半径求和。半径定义：i-k>=0 && i+k < n && x[i]大于[i-k,i+k]中除了x[i]之外的所有数。
数列生成方法：x[0]=x0, for (i:1->n-1) x[i]=(x[i-1]^a+b)&(1<<50 - 1)。
Solution：
既然不能全部算好load进来，那么就online地处理。由x[i]得到x[i-1]的方法：((x[i]+(1<<50)-b)^a)&(1<<50 - 1)。
然后暴力地扫每个数字就行了。因为按照x[i]从大到小来看，实际上会分成很多段，那么扫到的数字的次数是nlogn的。

SRM 682 Div1 Med
n(n<=50)个点n(n<=50)条边的无向联通图，通过每次选两个点合并来达到最终局面：存在一个点，任意一对顶点之间的路径都要经过这个点。问最少合并次数。
Solution：
首先环一定要合并起来，然后非叶节点也要合并到一起。但是有个坑：就是在环上存在degree=2的点的时候可以少合并一次(因为合并完后这个点就会变成叶子。)

SRM 688 Div1 Easy
n(n<=1000)的小括号序列，每次可以选一段[L,R]把它们翻转，问不超过10次翻转能否把这个序列变成合法序列。
Solution：
遇到括号匹配的问题如果不是dp或者搜索，可以多考虑stack。
因为被反转序列中已经合法的括号子序列可以被无视，因此stack维护出来之后只剩")))...(((..."or")))..."or"(((..."这种。之后可以直接搞。

SRM 688 Div1 Med
长度为n(n<=2000)的小括号序列，每次可以选两个位置交换。问最少多少次，把序列交换到满足给定的m(m<=2000)个区间都是合法区间。
Solution：
对于一段序列，如果total的和是0，那么可以通过内部交换来达到变成合法序列。可以注意到，每次选最左端的"("和最右端的")"交换，可以使得最小值增加2。
因此需要ceil(-w/2)次交换来把它变成合法序列，其中w为区间最小值。如果total的和非0，那么要通过和序列外的位置交换来达到目的。
给定的区间可能是重合，嵌套和交叉。如果是交叉，可以发现每两个交叉区间[l1,r1][l2,r2](l1<l2<=r1<r2)可以拆成三个不相交的区间。
那么只剩下嵌套的情况。可以建一颗🌲，一个区间A嵌套了另一个区间B，那么A就是B的父亲。接下来只要dfs求出。
注意拆区间的时候只要暴力地每次找出交叉区间然后拆就行了。

SRM 689 Div1 Med(construct)

SRM 690 Div1 Easy
从1－100里选出K(K<=15)个数。使得这K个数的子集，无论如何组不成给定的N(1<=N<=100)。
Solution：
找一个最小的不能整除N的数x，然后取x的K倍。
但是N＝60，K＝15的时候要特判。因为需要用x＝7，可是100/7<15。那么就先拿1，剩下14个数不能凑59也不能凑60。

SRM 695 Div1 Easy
构造长度为n(n<=50)的只含ab的串，使它满足长度为i+1的重复子串有x[i]个(|x|=n)。
Solution：
答案必然为a...和b...交替出现。其中应该放尽量长的a...在前面，如何不能再放就放尽量短的b...。那么就处理出不同长度的重复子串有多少个，按照长度排序。
然后最长的放在最前面，全a，剩下的找最短的，全b，放在后面，再找最长的，全a...交替进行。

SRM 699 Div1 Easy
n(n<=40)个人，每个人选一个[0,2^30)的数字，然后每一个人要么保持沉默要么说出除了自己以外其他所有人的数字的xor。问能否估计所有人和的最小值。
Solution：
对于每一位看，答案是1的人必然这一位相等，答案是0的人必然这一位相等。因此枚举答案是1的人这一位为1还是答案是0的人这一位为0。之后根据奇偶判断，
不够的可以用保持沉默的人填补。

♥️SRM 706 Div1 Med ✨
长度为n(n<=3000)的数字序列，每个元素[1,3000]，给每个数字映射一个字母[A,B,C]，问使得所形成的字符串含有ABC作为子序列的不同的映射方案数。
Solution：
枚举第一个A和最后一个C。那么第一个A之前的只能是BC，最后一个C之后的只能是AB。中间的随便。那么每个数字就对应了一个3bit的状态，表示它可选的字母集合。
但是因为至少要选一个B，那么就要减去所有人都不选B的方案数。那么数字就分成了不出现在AC之间的和出现在这之间的。
一个trick：
把数字按照合法的状态分类，假设当前合法状态为mask的数字有x个，那么预处理出f[mask][x]的乘积结果。

SRM 707 Div1 Easy
要求构造一个不超过50*50的矩阵，使得从左上顶点到右下顶点，最短路长度为k(k<=1000)。
Solution：
当k<=49+49的时候，直接以最短路n-1+m-1构造n*m的矩阵即可。当k>98的时候，意味着即便是50*50的矩阵也需要拐弯才能走k的距离。那么可以构造以pattern A重复
的矩阵。50 * 50的pattern A能cover所有k>=98 & k is even的方案，50 * 49的pattern A能cover所有k>=97 & k is odd的方案。
pattern A形如：
1) 50 * 4.
2) 第一列和第三列空白。
3) 第二列除了最后一行都是障碍(w)。
4) 第四列除了第一行都是空白(z)。
实现的时候，w和z可以分开分别填，隔4列填一次。

SRM 708 Div1 Easy
构造n(n<=100)个小写字母string，每个长度<=100。满足n个string的A-number和B-number相等。
定义A-number：同一个string中位置相邻但字母不同的切换次数。
定义B-number：不同string中相同字母的pair数（无序）。
Solution：
假设n<=26那么就是简单地a,b,...z即可。如果是27，必然会有重复。假设为a,a,b,...z。为了匹配a,a就需要在同一个string里出现A-number。
一种可行的方案是，bcb。那么再来考察，加多一个a的情况。那么对应地bcb->bcbcbcb，长度也就是C(3,2)*2+1。那么也就是说(a,b,c)三元组，在长度不超过100的
情况下，可以加多9个a。这样算下来，26/3 * 9 + 26 = 98。还剩下y和z没有用到。可以用来构造n=99和n=100的情况，即使用(v,y,z)三元组。
