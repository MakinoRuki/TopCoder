SRM 603 Div1 Easy
n(n<=50)个顶点的一棵无向树，两个人轮流，每个人选一条边切断，然后保留其中一棵子树。直到剩最后一个顶点。
每个顶点有权值，先手想让所剩最大，后手想让它最小。问最终结果是什么。
Solution:
最终所剩一定为叶节点。假设结果顶点邻接边大于1，那么对手在下一轮一定不会让它保留。所以最终结果必然是只有一条邻接边。先手直接take it。

SRM 607 Div1 Med
一排n(n<=2500)个转轮，每个转轮上面刻了一圈0-9的数字，每次可以选一个连续区间，把这个区间里的轮同时向上转1或者向下转1。
问从初始状态S转到目标状态T最少转多少次。
Solution：
首先重写一下条件。要把S调到T，实际上就是要把delta(S-T)调到0。那么变成000...000也就意味着相邻两项之间的差值%10=0。
因此可以考察R[i]=(S[i]-T[i])%10的相邻两项之间的关系，我们设这个delta为S[i]=R[i] - R[i - 1],S[0]=R[0]。
那么对于R的操作可以转化成对于S的操作。
如果是选一段[i,j]加1，实际是S[i]+1,S[j+1] - 1。减同理。如果是从i到结尾加1，则是S[i]+1，其余不变。减同理。
则，每次调整要么选两个S[i]配对加减，要么单个加减。
那么就可以把S排序，小的数向下调到0，大的数向上调到10。那么怎么定义是大还是小呢。排序之后枚举分界点即可。
kmjp说：为什么我不dp呢。因为这题是475pt啊。致敬。

SRM 608 Div1 Easy
n(n<=50)个物品，每个物品有个范围low[i]-high[i]。总值加起来为c。从中选出subset，使得加和至少为x。问最少选多少个。
Solution：
假设给出一个subset，如何判断它合法。就是low[i]的和以及c-(不在subset中的high[i]的和)取较大值，它>=x即可。
那么在选的时候，就是low[i]排序，从大到小取。然后high[i]排序，从小到大取再用c减掉就可以了。

SRM 609 Div1 Med
k(k<=10^5)种物品，每种10^9个。现在要分成一些package，每个package里有1-k个物品。使得每个package里要么全部一样，要么全部不一样。
问最少多少个package。
Solution：
尽量填满k个。所以先每种取尽可能多的k的倍数。然后排序。
之后枚举分界点i，i之前的全部不一样，i之后的全部一样。

SRM 611 Div1 Easy
n(n<=50)个不同数字组成的数组A，m(m<=50)个不同数字组成的数组B。LCM(A)为由所有A子集的lcm组成的集合，LCM(B)为由所有B子集的lcm组成的集合。
问LCM(A)是否等于LCM(B)。
Solution：
如果对于A中任意一个数字，B中都存在一个子集的lcm与它相等。则LCM(A)含于LCM(B)。反之，若A中存在一个数字，在B中不存在一个子集的lcm与它相等，
那LCM(A)和LCM(B)必不相等。反之亦然。
那么就枚举A中每一数字，看B中所有能整除这个数字的元素的lcm是否与这个数字相等。对B同样处理。

SRM 612 Div1 Easy
有一个字，想把它变成n(n<=1000)个。每次可以copy所有到剪切板，可以粘贴所有回原串，可以从原串删除一个字。
问最少步数。
Solution：
如果要删除，一定是最后一步删除多余的。
那么dp[i]表示打i个字最少步数。枚举j<i，那么dp[i]=dp[j]+(i/j+(i%j!=0))*j-i。

SRM 616 Div1 Med
有n(n<=60)种硬币，其中v[i] | v[i+1](v[i] <= 10^18)。每种硬币有个颜色，不同硬币互不相同。
可以有一些询问，每次询问一个价值c,会得到硬币数目最少的唯一表示法(因此可以看到一些硬币的颜色)。
问最少多少次询问可以确定所有硬币的颜色。
Solution：
设询问为行，每种硬币类型为列。cij是每次询问每种硬币的个数。因此能区分所有硬币就要求任意两列不相等，且每列至少有个1。
按照v[i+1]/v[i]把列排序，对于前j列，不同的合法列有(v[j+1]/v[j])^q - 1种(q为询问个数)。因此枚举列，取最大即可。

SRM 647 Div1 Easy
给10^5个building设定高度，满足building[1]=0，相邻两个building高度delta<=1，所有高度非负数。
且满足，给定x(size<=50)和t，building[x[i]] <= t[i]。
问能达到的最大高度多大。
Solution：
枚举最大高度是哪个，然后check能否满足每一对(x,t)。

SRM 649 Div1 Easy
给一个长度为50的大写字母字符串，现在要扣掉K个，问扣掉之后给你新串和原串，问你是否能猜出是扣掉了哪些位置。
Solution:
只要看相同的字母，它们之间的距离是否<=k即可。

SRM 649 Div1 Med
给一个10^5的数组A，每个数都在[0, 2^30)之内。让你选一个B∈[0, 2^30)，跟A的每一个元素异或，得到C数组。
要使得C数组中(i < j && C[i] < C[j])的pair之和最大。
Solution:
拆位来看。
对于某一位，我们把n个数的这一位都取出来，得到一个01序列。
那么要求的pair数理应为这个01序列的pair数+这一位为0的所有数组成新序列的pair数+这一位为1的所有数组成新序列的pair数。之后递归求解。

SRM 655 Div1 Easy
20*20的全W矩阵init。每次可以选择一块k*k的区域全涂黑或者全涂白。问最后是否能达到给定矩阵tar。
Solution：
最后一次涂过之后肯定剩下了一块k*k的纯色矩阵。那么每次试图找这样一块k*k纯色(或有待定色x)矩阵，里面的内容全部换成待定色x。
这样最后如果剩下整个n*n只有纯白或者待定色x，那么就是OK的。

SRM 665 Div1 Med
n(n<=500)顶帽子按某顺序排放，每顶i上写了一个正整数x和一个正整数y。其中y要么等于i以及i之前所有帽子上x的和，要么等于i以及i以后所有帽子上x的和。
给定x的数组A和y的数组B，问有多少种不同的AB数组和帽子的对应关系。
Solution：
首先考察可以发现(sum[i] == value[i] || sum[i] == total sum)的应该有且仅有两个。那么就先把这两个放在两端。
在放第三个的时候，从目前较小的一端开始。可以发现满足(value[i] + X == sum[i] || total sum - X = sum[i])的可以放在这里的hat，
只有在两端相等的时候有两个，其余情况有且只有一个。因此要么乘以2，要么什么也不做。

SRM 668 Div1 Easy
r(r<=50)*c(c<=50)的格子，问是否能从某个格子出发不重不漏地遍历每个格子k(k<=50)次。
Solution：
R*C是偶数时都有解，是奇数时只有K==1才有解。
原因的话，从此出发能遍历所有格子的点，和不能遍历的点是相邻的。也就是说一个能遍历的点周围都是不能遍历的点。
相当于黑白染色，从黑格子出发可以回到黑格子；然而从白格子出发要回到白格子则路径长度不够R*C。

SRM 669 Div1 Easy
长度为S(S<=1000)的长条，每次选一段切一刀。切下去之后得到长度为x和y的两段，则得分为x*y。问使得得分>=M最少切多少刀。
Solution：
假设来k个round，那么最终分成k + 1段。比如k = 2, 代价则为x=a1*(n-a1) + a2*(n-a2) + a3*(n- a3)。那么x/2 >= M的话，k就是解了。
要使x最大，则几段尽量均分即可。

SRM 669 Div2 Hard
n(n<=16)个点的完全图，每条边边权是1or2。对于2^(n*(n-1)/2)种图中的每一个，count线型生成树的个数，然后对所有图加和。问和是多少。
Solution：
2^(n-1)枚举每条边的边权。然后对于一个生成line计算出可以出现在多少个完全图中。每加一条边，形成的环中原先line上的边最大值不能超过新加的边。
因此暴力计数check即可。最后再乘以n!/2。

SRM 674 Div1 Med
n(n<=200000)辆车在一个无穷坐标轴上，每辆车有个初始方向。每辆车每秒走1个单位，两辆车碰到之后会以原速度都反向。
给出q(q<=200000)个询问，求t[i]时刻car[i]与0点的距离差。
Solution：
🍎蚂蚁系列进阶。🍏
1）蚂蚁相碰可以看作方向没变，穿过之后继续前进。
2）蚂蚁相碰之后相对位置不会改变，原先排第几现在还排第几。
3）对于本题，每次相当于是求t[i]秒之后位移排在第car[i]的点是谁。
也就是从一堆坐标中找第k大点的坐标。那么可以二分这个坐标，check有多少<=二分得到的坐标值的。

SRM 675 Div1 Med
使用x[i] = (x[i - 1] * a + b) % 1000000007的式子产生5000000个数字，100个query询问第k大的数字求和。但是内存要求每次只能使用260000个int。
Solution:
分段的思想。设置一个delta=30000。按照x[i]/delta的结果分段。统计一段中有多少个数字。
query的时候先查看k是在第几段，然后在这一段中按照x[i]%delta继续分组。找到第几组，也就是结果%delta的余数是多少。确定答案。

SRM 680 Div1 Med
构造一个n(n<=1000)个点m(m<=1000)条边的无向图，使得找MST的算法A在这个图上跑k(k<=1000)次刚好能找出MST。无解返回-1。
算法A:算法每趟跑时，对于图中的每一个联通分量找一条只有一个顶点在这个分量里的最小边，然后把找到的所有这样的边加到MST的边集里。
Solution：
最慢的生成方式是每次消去一半的联通分量(两两连接)。这样进行k-1次，剩下所有的联通分量在最后一轮(第k轮)连到一起。不够m条边就在没连起来的pair上连起来。

SRM 681 Div1 Easy
每辆飞船有m(m<=10^5)个part，n(n<=50)个工厂去制造它们。每个工厂可以制造a[i]到b[i]之间的k[i]个part，问最多能造多少艘船。
Solution：
可以二分答案。check的时候工厂按照a[i]排序。从小到大枚举part编号，每个part枚举到的时候，a[i]<=part的工厂都加进set，加进来之后按照b[i]从小到大消耗。

SRM 681 Div1 Med
n(n<=10^7)个数字，在内存只有1M情况下找出每个数字的半径求和。半径定义：i-k>=0 && i+k < n && x[i]大于[i-k,i+k]中除了x[i]之外的所有数。
数列生成方法：x[0]=x0, for (i:1->n-1) x[i]=(x[i-1]^a+b)&(1<<50 - 1)。
Solution：
既然不能全部算好load进来，那么就online地处理。由x[i]得到x[i-1]的方法：((x[i]+(1<<50)-b)^a)&(1<<50 - 1)。
然后暴力地扫每个数字就行了。因为按照x[i]从大到小来看，实际上会分成很多段，那么扫到的数字的次数是nlogn的。

SRM 682 Div1 Med
n(n<=50)个点n(n<=50)条边的无向联通图，通过每次选两个点合并来达到最终局面：存在一个点，任意一对顶点之间的路径都要经过这个点。问最少合并次数。
Solution：
首先环一定要合并起来，然后非叶节点也要合并到一起。但是有个坑：就是在环上存在degree=2的点的时候可以少合并一次(因为合并完后这个点就会变成叶子。)

SRM 688 Div1 Easy
n(n<=1000)的小括号序列，每次可以选一段[L,R]把它们翻转，问不超过10次翻转能否把这个序列变成合法序列。
Solution：
遇到括号匹配的问题如果不是dp或者搜索，可以多考虑stack。
因为被反转序列中已经合法的括号子序列可以被无视，因此stack维护出来之后只剩")))...(((..."or")))..."or"(((..."这种。之后可以直接搞。

SRM 688 Div1 Med
长度为n(n<=2000)的小括号序列，每次可以选两个位置交换。问最少多少次，把序列交换到满足给定的m(m<=2000)个区间都是合法区间。
Solution：
对于一段序列，如果total的和是0，那么可以通过内部交换来达到变成合法序列。可以注意到，每次选最左端的"("和最右端的")"交换，可以使得最小值增加2。
因此需要ceil(-w/2)次交换来把它变成合法序列，其中w为区间最小值。如果total的和非0，那么要通过和序列外的位置交换来达到目的。
给定的区间可能是重合，嵌套和交叉。如果是交叉，可以发现每两个交叉区间[l1,r1][l2,r2](l1<l2<=r1<r2)可以拆成三个不相交的区间。
那么只剩下嵌套的情况。可以建一颗🌲，一个区间A嵌套了另一个区间B，那么A就是B的父亲。接下来只要dfs求出。
注意拆区间的时候只要暴力地每次找出交叉区间然后拆就行了。

SRM 689 Div1 Med(construct)

SRM 690 Div1 Easy
从1－100里选出K(K<=15)个数。使得这K个数的子集，无论如何组不成给定的N(1<=N<=100)。
Solution：
找一个最小的不能整除N的数x，然后取x的K倍。
但是N＝60，K＝15的时候要特判。因为需要用x＝7，可是100/7<15。那么就先拿1，剩下14个数不能凑59也不能凑60。

SRM 695 Div1 Easy
构造长度为n(n<=50)的只含ab的串，使它满足长度为i+1的重复子串有x[i]个(|x|=n)。
Solution：
答案必然为a...和b...交替出现。其中应该放尽量长的a...在前面，如何不能再放就放尽量短的b...。那么就处理出不同长度的重复子串有多少个，按照长度排序。
然后最长的放在最前面，全a，剩下的找最短的，全b，放在后面，再找最长的，全a...交替进行。

SRM 699 Div1 Easy
n(n<=40)个人，每个人选一个[0,2^30)的数字，然后每一个人要么保持沉默要么说出除了自己以外其他所有人的数字的xor。问能否估计所有人和的最小值。
Solution：
对于每一位看，答案是1的人必然这一位相等，答案是0的人必然这一位相等。因此枚举答案是1的人这一位为1还是答案是0的人这一位为0。之后根据奇偶判断，
不够的可以用保持沉默的人填补。

♥️SRM 706 Div1 Med ✨
长度为n(n<=3000)的数字序列，每个元素[1,3000]，给每个数字映射一个字母[A,B,C]，问使得所形成的字符串含有ABC作为子序列的不同的映射方案数。
Solution：
枚举第一个A和最后一个C。那么第一个A之前的只能是BC，最后一个C之后的只能是AB。中间的随便。那么每个数字就对应了一个3bit的状态，表示它可选的字母集合。
但是因为至少要选一个B，那么就要减去所有人都不选B的方案数。那么数字就分成了不出现在AC之间的和出现在这之间的。
一个trick：
把数字按照合法的状态分类，假设当前合法状态为mask的数字有x个，那么预处理出f[mask][x]的乘积结果。

SRM 707 Div1 Easy
要求构造一个不超过50*50的矩阵，使得从左上顶点到右下顶点，最短路长度为k(k<=1000)。
Solution：
当k<=49+49的时候，直接以最短路n-1+m-1构造n*m的矩阵即可。当k>98的时候，意味着即便是50*50的矩阵也需要拐弯才能走k的距离。那么可以构造以pattern A重复
的矩阵。50 * 50的pattern A能cover所有k>=98 & k is even的方案，50 * 49的pattern A能cover所有k>=97 & k is odd的方案。
pattern A形如：
1) 50 * 4.
2) 第一列和第三列空白。
3) 第二列除了最后一行都是障碍(w)。
4) 第四列除了第一行都是空白(z)。
实现的时候，w和z可以分开分别填，隔4列填一次。

SRM 708 Div1 Easy
构造n(n<=100)个小写字母string，每个长度<=100。满足n个string的A-number和B-number相等。
定义A-number：同一个string中位置相邻但字母不同的切换次数。
定义B-number：不同string中相同字母的pair数（无序）。
Solution：
假设n<=26那么就是简单地a,b,...z即可。如果是27，必然会有重复。假设为a,a,b,...z。为了匹配a,a就需要在同一个string里出现A-number。
一种可行的方案是，bcb。那么再来考察，加多一个a的情况。那么对应地bcb->bcbcbcb，长度也就是C(3,2)*2+1。那么也就是说(a,b,c)三元组，在长度不超过100的
情况下，可以加多9个a。这样算下来，26/3 * 9 + 26 = 98。还剩下y和z没有用到。可以用来构造n=99和n=100的情况，即使用(v,y,z)三元组。

SRM 710 Div1 Easy
n(n<=10)个slot围成一圈，每个slot里面有不超过10个token。每次可以执行AB两种操作中的一种。
A操作是，选一个非空slot，拿出里面token，然后顺时针转圈，每走一个slot丢一个token。
B操作是，选一个非空slot，逆时针转圈，每走一个slot拿起一个token。然后走到一个空的slot就把当前的token全部丢进去。
问从source状态到target状态，2500步之内的一个操作序列。
Solution：
首先发现AB操作是互逆的。那么如果存在一个中间状态U，使得可以通过A操作S->U且T->U，那么就可以通过B操作U->T。
这个中间状态的选取可以是：全部token丢到0号slot里。
方法就是，while循环中每次找一个非空的slot执行A操作。那么由于0号slot只进不出，考察1号slot，10步以后到0。
那么100个token全部到0就是最多10*100=1000步。因此2000步是个非常宽松的上界。

SRM 711 Div1 Easy
给一个不超过50位的数字n，找一个大于等于n的二进制表示有连续k(k<=50)个1的数字。
Solution：
枚举这k个1在哪里。如果n中有对应的k个1，那么n就是答案。否则n的这k位中必然有0，那么这k位之后的位可以全部变为0。

SRM 712 Div1 Easy
n(n<=50)个数字序列s，要把它通过L或者R操作变成t。L操作是每个数加上它左边的数，R操作是每个数加上它右边的数。求一个长度不超过100的LR序列，使得s变成t。
Solution：
LR交替是没有意义的，那么就枚举LR序列的长度，枚举有多少个L，然后暴力验证。
有一个观察可以省去枚举LR序列的长度，就是每次不管是L还是R操作，序列的sum都相当于乘以2。那么可以迅速直接求出LR序列的长度。

SRM 714 Div1 Easy
n(n<=2500)的合法(配对)括号序列，每次去掉最开始的"("，然后找一个去掉之后整个序列仍保持合法的")"去掉。问有多少方案能把整个序列拿空。
Solution:
如果记"("为+1,")"为-1。那么原序列可以拆成sum为0的一些段。对于每一段，每一个"("，可选的配对的")"的个数从右到左逐渐递增。
那么对于每一段，从右到左遍历"("，乘积即可。

SRM 714 Div2 Hard
n(n<=300)个position，每个位置有个值x,在[-10^5, 10^5]之间。一个人从0出发，遇到正值就买货，遇到负值如果货物够了就卖货。
问满足所有人需求的情况下，走到最右端，最少走过的距离是多少。
Solution：
遇到正值就买入，遇到负值如果不能满足就记下，当遇到一个正值，所积累sum能满足之前整个一段积累的负值时，就返回，满足这一整段的负值。

SRM 716 Div1 Easy
给出三个数字ab,bc,ca,长度都不超过50。求构造三个长度不超过1000的01串ABC，满足LCA(A,B)=ab,LCA(B,C)=bc,LCA(C,A)=ca。
Solution：
三个数字排个序，从小到大处理。假设ab<=bc<=ca。
那么先构造AB串，各添加ab个0。
然后构造BC串，使其都有bc个0。因为ab<=bc，所以不影响AB串的LCA。
然后对于CA，ca-ab差多少，就补多少个1。这样互相不影响。

SRM 717 Div1 Easy
n(n<=100)个顶点的无向完全图，给每条边一个方向。给出每个顶点的出度，问有多少互相可达的(u,v)点对。
Solution：
完全图每个顶点的度数和为n-1。排序，从出度最大的点向出度最小的点连出边，剩下的n-1-deg(u)是入边。

SRM 718 Div1 Med / Div2 Hard
n(n<=2000)个城市围成一圈，在任意实数坐标放置转送装置，共放k(k<=n)个。城市之间有距离，传送装置之间瞬移。采取某种放置装置的方法，使得任意两个城市之间
距离的最大值最小。
Solution：
两个城市之间的距离，应该等于两个城市距离它们最近的传送装置的距离的和。对于每一个城市，会选择距离它最近的那个传送装置。
那么对于两个传送装置，设它们的中点为M，那么M左侧的选择左边装置，右侧的选择右边装置。
那么就意味着，每个传送装置会覆盖等长的一段线段。只要二分这个线段长度，看能否用k个cover全部n个城市就好。
对于环形，枚举从哪里拆开。因为每个城市肯定只会被一段线段覆盖。

SRM 719 Div2 Hard
n(n<=1000)个顶点的一棵树，每条边上有个权重。找两条没有重合边的path，边权权重xor值最大。
Solution：
1) 相当于任选2对顶点，path的xor值xor。可以预处理xor值为x的pair。然后枚举x1,x2。
2) dp。f[i,j]表示选了i个顶点，xor值为j的方案是否可行。然后自顶向下dp。

SRM 720 Div1 Easy
10个数字，给定每个数字的个数上限(不超过100)。用这些数字凑两个允许前导0的不超过100位的数字A和B，求A*B。
Solution：
对于任意两个数字(相同或者不同)，枚举它们所在的位置。可求A*pw1 * B*pw2。然后对于剩下的位置，dp。dp[i,j]表示前i个数字摆满了A和B中的j位的方案数。

SRM 721 Div1 Easy
1-d1天完成w1个任务，1-d2天完成w2个任务。在这d1+d2天里完成w1+w2个任务且相邻两天任务个数delta不超过1。问是否possible。
Solution：
在交界处的两天d1和d1+1，会有完成任务的个数的可能区间。单增得到的是最大值，单减得到的是最小值。二分最值，看这两个最值是否可能差1以内。
二分最小值x1，那么要满足x1+...+x1+d1-1 >= w1。
二分最大值x2，那么要满足x2+...+x2-d1+1 <= w1。但是二分最大值的时候注意x2-d1+1可能小于0。那么就是1+...+x2 <= w1。

TCO17 R1B Div1 Med
使用不超过20个正整数，每个数不超过10^9，组成一个set。使得此set的子集能够凑成的不同数字恰好k(k<=10^6)个。
Solution：
x个数字所能凑成的最多的个数就是把x个2的power摆在一起。从k中减掉这x个2的power之后如果还剩y，就可以直接把y放进去。

TCO17 R2C Div1 Easy
n(n<=50)个🐺和n(n<=50)个🦊，n个round。每一个round，狼按照编号从小到大上跷跷板，狐狸采用某种策略顺序上跷跷板。每一个round总重量大的得一分。
求🦊得到k分的方案。
Solution：
从后往前看。假设现在n个🐺在板上，n个🦊在板上。n号狼离开的时候，which🦊离开取决于前n-1个🦊能否得到k-x(x为0或者1)分。
那么这n-1个🦊得分最少为从轻往重上，得分最多为从重往轻上。

SRM 723 Div2 Hard
十字形摆放5个n*n(n<=10^9)的格子。问两两之间曼哈顿距离的和是多少。
Solution：
可拆分成deltaX和deltaY。对于deltaX，可以以列为单位看；对于deltaY，可以以行为单位看。

SRM 724 Div1 Easy
n(n<=50)个数，给出pairOr[i] = x[i] or x[i + 1], pairSum[i] = x[i] + x[i + 1]。问存不存在合法的序列x。
Solution：
观察可得pairSum[i]-pairOr[i]所得即是所有x[i]和x[i+1]都为1的位,pairOr[i]=0即为x[i]和x[i+1]都为0的位。
因此可以拆位来看，确定哪些位是1哪些是0。之后再根据已经确定的位来check那些不确定的位/x[i]和x[i+1]中有且仅有一个是1的位。

SRM 724 Div1 Med
给一个n*m(n,m<=50)的目标矩阵，由.和#构成。可以执行四种操作up,down,left,right。每个操作意味着向该方向推动所有#，
到不能再推的位置(到了边界或者卡到另一个#)。问可以得到目标矩阵的初始矩阵方案数mod 1e9+7。
Solution：
几个观察：
1.每个操作有意义的只有第一次执行。
2.如果某个#在某个方向上有一个相邻的"."，说明不能执行该方向上的对应操作。
3.分几种情况讨论：
四个方向都不能执行，则为1；
只有一个方向上可以执行(比如up/down)，则为C(n,c1) * C(n,c2) * ... C(n, cm)；
两个方向上都可以执行(比如up/left)，则分为up->left和left->up，那么设有x个#的列有numx个，
则为C(m,num1)*C(m-num1,num2)*...*C(numx,numx)*C(n,c1)*C(n,c2)*...*C(n,cm) + 
C(n,num'1)*C(n-num'1,num'2)*...*C(num'x,num'x)*C(m,r1)*C(m,r2)*...*C(m,rn)
然后减掉既能up->left又能left->up得到的方案数，即：
C(m,num1)*...*C(numx,numx)*C(n,num'1)*...*C(num'x,num'x)。

SRM 727 Div1 Med
给一个board，从中选出一个边和board的边平行的grid，全部mark成'#'。board剩余部分是'.'。然后按照行把这些string拼接到一起得到一个大的string，
给出这个string的subsequence，问最少可能missing的cell有多少。
Solution：
假设一行是x个'.'+y个'#'+z个'.'。枚举xyz(x,z <= max{.}, y<=max{#})，然后模拟去把有多少行取出来。
非常考coding和实现的一道题。

SRM 728 Div1 Easy
给n(n<=50)根长度不超过10^9的stick，对于某一根，长度L为偶则变成L/2，否则变成(L-1)/2或者(L+1)/2。
问把所有变成长度相等，最少多少次操作。
Solution：
首先必须先知道最终长度多长。最终长度either为某一个prefix，either为某一个prefix+1。
然后枚举每一根，如果当前长度L>res_L，则/=2，否则+1/2。

SRM 729 Div1 Med
给一个1000*1000的grid，要从(sx,sy)跳到 (tx,ty)。在位置(x1,y1)时可以跳到(x2,y2)，只要(x1-x2)^2+(y1-y2)^2>=d^2(d<=2000)。
问最少步数。
Solution：
不要以为可以只特判1,2,3!!!因为会有4!!!
但是，只有边界四周的点有意义。所以我们只要把边界点拿出来爆搜就可以了！！！

SRM 730 Div1 Med
给定k(k<=23)，求构造不超过46个顶点的无向图满足对于任意0<=i<=k(k-1)/2，存在k个顶点的子图，子图中exactly包含i条边。
Solution：
从最终极情况想，存在k个顶点的完全图，那么边数就是k(k-1)/2。那么我们去掉一个顶点，如果想要得到k(k-1)/2-1条边，就要加上一个与其他顶点连边k-2条的顶点。
以此类推加上k-2个顶点。
当边数再向下减掉O(k)的时候，重复利用这几个顶点，但是要有一个始终和所有点不相连的顶点x。这个顶点可以重复使用上一个O(k)时连边数为1的顶点。
这样，加的边不超过k个。构出的图不超过2*k。

SRM 732 Div1 Easy
20*20的矩阵，每个点w,b,e，其中非e的cell两面为w或b。每次选一个点翻转，同时它周围跟它联通的一片同色的点也都跟着翻转。问经过最少多少次翻转后，
全部非e的cell都能翻成同色。
Solution：
最优解一定是以某个顶点为中心不停翻转，每次扩展一圈到同色。
因此枚举起点求最短路最长为多少，然后分别更新为b或者为w的解。

TCO18 Poland Hard
n(n<=100)张牌，两面是a[i]和b[i]的数字，都是没有前导0的正整数。2^n种翻面情况中的每一种，会把这些数拼成一个可能的最小的数字。
问所有2^n个数字的sum(mod 10^9 + 7)。
Solution:
对于每个数的每个面i，可以算出其他每个数的每个面j排在它的前面还是后面。设j这个面上的数长度为x，那么排在i前面，对结果的贡献就是1，
排在i后面对结果的贡献就是10^x。枚举之后扫一遍求和。

TCO18 R3A Med
长度为n(n<=10^5)的数组，有正有负有0。问乘积不超过limit(limit<=10^9)的subarray有多少。
Solution:
首先看绝对值。对于一个i，绝对值>1的数(最多logn个)的乘积不超过limit的位置作为右端点。在这个右端点的右边，只考虑负数和0。
那么就从右往左扫一遍，维护一个双端队列以及0和负数的个数。

TCO18 R3B Hard
有一个leadCoin，有n(n<=50)个操作，每个操作消耗1个leadCoin产生a[i]个leadCoin和b[i]个goldCoin。
问执行任意组合操作多次之后是否能得到0个leadCoin和goal(goal<=10^18)个goldCoin。
Solution:
首先必然是执行多次操作组合之后保持leadCoin不变，goldCoin增加。最后再来一次a[i]=0&&b[i]>0的操作，得到goal。
可以先dp出leadCoin增加0，goldCoin可能增加多少。
把操作分成a[i]=0的和a[i]>0的。用a[i]>0的操作初始化dp[a[i],b[i]]=true。
然后用a[i]=0的b[i]去背包dp，得到为true的dp[0,c]。
那么c1*x1+c2*x2+...+cn*xn=goal-b[i]。
这个式子要有解，也就是c2*x2+...+cn*xn=(goal-b[i])%c1要有解。
但是判断的时候要使用gcd(c1, c2, ..., cn)|((goal - b[i]) % c1)。
判完有解之后，求(c2*x2+...+cn*xn)%c1的最短路，只要存在一个i满足最短路<=goal-b[i]即可。

SRM 737 Div1 Hard
构造一个长度不超过373的只含7和3的string，满足737这样的子序列有x个(x<=1737373)。
Solution:
均分最大。假设从7...3...7...开始，枚举左边和右边7的个数side，求出mid=ceil(x/(side*side))。
然后从左到右枚举每个3往左移动多少(1<=j<=side)，减掉2*j-1判断。
