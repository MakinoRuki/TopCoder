SRM 658 Div2 Hard
n*n(n<=50)的矩阵，每个格子是O，E，？。mat[i,j]='O'表示ij之间奇数条边，mat[i,j]='E'表示ij之间偶数条边，mat[i,j]='?'表示不确定。
要求给出一棵树，满足矩阵里的条件。
Solution：
将图黑白染色。为了防止全部染成白色/黑色，给第一个联通分量以黑色init，其他分量以白色init。

SRM 684 Div2 Hard
n(n<=50)个点，每个点两个出度。问能否从0出发，每个点遍历至少一次。
Solution：
条件是，任意两个点之间都有某一个或两个方向联通且0能到达任意一个点。

SRM 687 Div1 Med(Gomory-Hu tree)

SRM 699 Div2 Hard
n(n<=100000)个点编号1-n，m(m<=500)条边，形如a[i]->b[i]。x->y有一条边当且仅当存在一个i，a[i]|x && b[i]|y。问S到T的最短路。
Solution：
就是找一条路径从S到T，问路径上边的条数最少。那么可以直接bfs，如果可以从边i走到边j，当且仅当lcm(b[i], a[j]) <= n。

SRM 699 Div1 Med
n<=10^9, m<=1000。做法同上。

SRM 704 Div1 Easy
构造一棵n(n<=50)个顶点的树，满足与第i个顶点距离最远的点的距离是d[i]。
Solution：
首先考察直径。然后剩下的点根据x[i]的关系连接到直径上面对应的非叶节点。讨论奇偶，corner case。比如直径是奇数，那么x[i]等于中间两点的只有两个；
直径是偶数，那么x[i]等于中间一点的只有一个。其余的直径上的点，与它们x[i]相等的点要>=2。

SRM 700 Div1 Med
有多少[1-n]->[1,n](n<=5000)的映射，满足无限次迭代以后收敛到k(1<=k<=n)个数。
Solution：
这样的映射必然会是一个有向图，一堆链指向几个环的形式。可以发现，k个数的排列和k个数组成一堆环的方案数相同。然后问题转化成n个顶点k个根，能生成多少森林。
方案数是k * n^(n-k-1)。

SRM 703 Div1 Easy
构造一个n(n<=50)个顶点的DAG，满足每个顶点reachable的顶点数是x[i]。
Solution：
既然是DAG，必然有x[i]=1的点。就像拓扑排序一样，每次把x[i]=1的点找出来往其他所有人连边，以此类推。
