SRM 608 Div1 Med
n(n<=50)个点的有向图，找一个多项式P(x)使得不管L取多大，长度为L的walk(path上的顶点可以重复出现)的条数始终以P(L)为上限。
问P(x)的degree最小是多少。
Solution：
考察一下这些图，发现当两个或两个以上的环有公共顶点的时候，walk的条数是指数级增长的(假设有两个相交环交于顶点o，长度分别为u和v。那么当长度为L的walk
有w条的时候，长度为L+uv的walk的条数就有w*2条(可以走u遍v或者v遍u)，L+2uv有w*2*2条，以此类推)。因此图中如果有环，则必是不相交的环。
那么求联通分量，缩点之后得到一个DAG。
当有一个环的时候，长度为L的walk数目是常数级别的；而两个分量的情况(A指向B)，当增加一个A的时候，增加的walk数目将是O(L)的
(假设前x个环走长度为L的path，方案数有y，那么第x+1个环走L+z*len的方案数就是y*O(L)的)。
那么每增加一个圈，增加O(L)的条数。因此在所求DAG里求最长路(含最多个长度大于1的环)，即可得到P(x)的degree。
Trick:
1.判断点在环上。floyd之后dp[i,j]=dp[j,i]=true。
2.判断点在多个环上。某个点在不同环上的in_degree>1 or out_degree>1。

SRM 612 Div1 Med
10^5*10^5的格子，有n(n<=50)个格子是特殊的。给出这些坐标，把x和y分别打乱，然后另一人去猜出这个格子。求最小的T，使得任意一个valid的猜测都至少
有T个特殊格子。
Solution：
对于第i行，假设需要有xi个特殊格子，对于第j列需要有yj个特殊格子。那么这些可以看做是容量，来进行网络流。
我们希望它尽量不走给出的特殊格子，所以对于特殊格子(x,y)，xx到yy的费用是1，否则费用为0。然后流量为n时输出cost。

SRM 615 Div1 Med
n(n<=50)个顶点，m(m<=50)条边的无向图。每条边有个边权<=10000。问是否可以在走过距离为T(T<=10^18)的时候刚好从0走到n-1。
Solution：
通过取模运算来压缩状态。随便取一个与0邻接的边设边长为d0，则有一个过顶点0的环长度为2*d0。dp[i,j]表示到顶点j距离mod 2*d0为i的最短路。
用set求出dp[T%(2*d0)][n-1]之后，看结果是否<=T即可。

SRM 617 Div1 Med
一共有n(n<=50)个人，有m(m<=1000)天，每一天会有两个人c1&c2，给其中一个人pie另外一个人dolphin。
问每个人pie数和dolphin数的差的和最小的分配方案是什么。
Solution：
抽象成图问题。如果给c1的是pie给c2的是dolphin那么连边c1->c2否则连边c2->c1。
现在就是要求所有点入度和出度的差的和的最小值。假设每个点的这个差都是0或者1，那么已经ok。否则根据degree守恒，
如果out[i]-in[i]>=2，则必然能找到in[j]-out[j]>0的点(det>=2显然可以，det=1则翻转后绝对值不变)。
那么每次bfs找到i对应的j，然后路径上所有的边全部翻转。

SRM 658 Div2 Hard
n*n(n<=50)的矩阵，每个格子是O，E，？。mat[i,j]='O'表示ij之间奇数条边，mat[i,j]='E'表示ij之间偶数条边，mat[i,j]='?'表示不确定。
要求给出一棵树，满足矩阵里的条件。
Solution：
将图黑白染色。为了防止全部染成白色/黑色，给第一个联通分量以黑色init，其他分量以白色init。

SRM 684 Div2 Hard
n(n<=50)个点，每个点两个出度。问能否从0出发，每个点遍历至少一次。
Solution：
条件是，任意两个点之间都有某一个或两个方向联通且0能到达任意一个点。

SRM 687 Div1 Med(Gomory-Hu tree)

SRM 699 Div2 Hard
n(n<=100000)个点编号1-n，m(m<=500)条边，形如a[i]->b[i]。x->y有一条边当且仅当存在一个i，a[i]|x && b[i]|y。问S到T的最短路。
Solution：
就是找一条路径从S到T，问路径上边的条数最少。那么可以直接bfs，如果可以从边i走到边j，当且仅当lcm(b[i], a[j]) <= n。

SRM 699 Div1 Med
n<=10^9, m<=1000。做法同上。

SRM 704 Div1 Easy
构造一棵n(n<=50)个顶点的树，满足与第i个顶点距离最远的点的距离是d[i]。
Solution：
首先考察直径。然后剩下的点根据x[i]的关系连接到直径上面对应的非叶节点。讨论奇偶，corner case。比如直径是奇数，那么x[i]等于中间两点的只有两个；
直径是偶数，那么x[i]等于中间一点的只有一个。其余的直径上的点，与它们x[i]相等的点要>=2。

SRM 700 Div1 Med
有多少[1-n]->[1,n](n<=5000)的映射，满足无限次迭代以后收敛到k(1<=k<=n)个数。
Solution：
这样的映射必然会是一个有向图，一堆链指向几个环的形式。可以发现，k个数的排列和k个数组成一堆环的方案数相同。
然后问题转化成n个顶点k个根，能生成多少森林。方案数是k * n^(n-k-1)。

SRM 703 Div1 Easy
构造一个n(n<=50)个顶点的DAG，满足每个顶点reachable的顶点数是x[i]。
Solution：
既然是DAG，必然有x[i]=1的点。就像拓扑排序一样，每次把x[i]=1的点找出来往其他所有人连边，以此类推。

SRM 703 Div2 Hard
n(n<=1000)个顶点的🌲，找出距离等于子树直径的点对最多的子树，输出这种子树中距离等于直径的点对数目。
Solution：
找到的子树应该尽量均匀，那么要么是一个顶点为中心，放射状的一堆距离相等的点；要么是一条边(a,b)为中心，a端和b端连着一些距离相等的点。
对于第一种情况，枚举中心点，然后枚举每个儿子dfs统计。

SRM 710 Div2 Hard
n(n<=300)个点，不超过m(m<=2500)条边。每条边有个边权每个点有个点权。定义d(u,v)为u和v所有路径上最大边权和最大点权的乘积的最小值。
求sum{d(u,v)}。
Solution：
floyd。但是在枚举中介点的时候，按照点权从小到大枚举。同时dp边权的最大值。这样对于枚举到(k,i,j)时，由于ij可能还没有做过中介点，
因此点权最大只能是在这三者之中。

SRM 721 Div1 Med
构造不超过1000个顶点和1000条边的简单图。使得距离为d的pair数exactly为k对。
Solution：
两种case。
一种是星状结构：一个中心，然后一堆边放射状。
一种是中间d-2的长条，然后两端要么x^2，要么x*(x-1)，其中x是一端的顶点个数。在k中从大到小枚举，逐次去掉这些x^2和x*(x-1)即可。

*TCO17 R2C Div1 Med*
n(n<=50)个顶点的图，Angel选不超过A条边，Demon选不超过D条边。
然后对于旧图中的每一条边，如果Demon选了就不出现在新图；否则，如果Angel选了就出现在新图；否则，在新图中remian旧图的样子。
如果新图存在0->n-1的路径则Angel胜，否则Demon胜。
问Angel和Demon是否必胜，或者是Unknown。
Solution：
神奇的网络流。建图：对于每一对边[i,j]，建立流量为1，费用为G[i,j]=='N'(旧图是否有边)。
然后从源到汇流量为D+1，费用为0。
这样如果flow>D && cost<=A则Angel必胜。否则如果D>=n-1，Demon必胜。否则Unknown。

TCO17 R2A Div1 Med
构造n(n<=50)个顶点的无向简单连通图，满足对于每一个顶点v，MinDis[0,v] = dis0[v] && MinDis[1,v] = dis1[v]。
Solution：
对于所有能连的边都连起来。那么考察每一对顶点，什么情况下才可以连边。
以0为例，根据dis0[v]数组将顶点集分成了多层。那么显然层数差<=1的才可以连一条边。也就是对于(u,v)，满足|dis0[u] - dis0[v]| <= 1的。
对于dis1[v]同理。
最后再floyd来check是否满足联通和dis0,dis1条件即可。

SRM 726 Div1 Med
n(n<50)个顶点的一棵树，选一个顶点的排列q，然后按照排列顺序遍历，统计走过的顶点走过的次数之后降序排序，找一个使得排序后次数序列字典序最大的排列q。
Solution：
重要的是要尽量多地集中访问某一个顶点。这个顶点最好要比较中心。那么就是求出重心。
然后从重心出发，每次从未访问节点最多的子树中找一个尽量远的顶点访问(且dfs序要尽量深，也就是按照dfs序从小到大保存儿子节点)。

TCO 18 R2A Med
n(n<=1000)个顶点的无向简单图，每个顶点deg<=2。现在要加边，使得每个顶点deg=2。问边集字典序最小是什么。
Solution:
按顶点编号从小到大枚举边。合法即可加进来:
1) n1=0, n0不能<=2
2) n0=0, n1=2时这两点不能是在同一条边上

SRM 736 Div1 Med
给出n(n<=10^9),m(m<=n*(n-1)/2),k(k<=10^9)，问n顶点m条边的所有图，是否都含有k-dense的子图，是ALL,NONE还是SOME。
k-dense子图是指子图中每个顶点的degree都>=k。
Solution:
首先边数最少的构造非NONE的方法是构造一个k+1个顶点的完全图。
因为它尽可能利用已有顶点，如果不是完全图，只会需要更多的边。
所以m<k(k+1)/2就是NONE。
对于ALL的情况，我们试图构造一个边数很多但就是没有k-dense子图的方案:
先构造一个k个顶点的完全图，然后n-k个顶点与这k个当中的k-1个相连。得到x=k*(k-1)/2+(n-k)*(k-1)条边。
如果m>x，则一定是ALL。
证明可以用数学归纳法。
