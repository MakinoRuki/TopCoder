SRM 644 Div2 Hard
SRM 646 Div1 Med
无穷大平面，一个人从原点出发，每秒可以上下左右移动一步。有n<=47个障碍物。问k<=10^9以内所能到达的x坐标最大的点x是多大。
Solution：
离散化。由于每次转向都必然是在障碍物附近。那么枚举以每个障碍物所在坐标为中心的九宫格，得到50*9个点，然后bfs。
每次搜到一个点后，尽量向右走，更新答案的x坐标。然后扩展到九宫格内的其他点。

SRM 648 Div1 Med
N=10^9种物品，要从中买K=10^9个。对于第i种来说，买第j个是i * (2^(j-1))元。
现在问，以总价钱最小来买这K个，买来的最贵的那个的价钱是多少。答案mod 10^9 + 7。
找找规律可以发现，第一个是买遍第一种，2-3买遍前2种，4-7买遍前4种，8-15买遍前8种，etc。至此规律明显了。
这样到了最后会存在一个2^x > N，那这时候一定是1-n种各买一个，一遍又一遍地买下去。此时我们便可以看成是，所有的物品实现买了m次，
将原来的K弱化掉m * N之后，再来求解本题。这时候就可以放心二分最贵价钱啦！
统计个数的时候，注意到一定是i小的买的次数多，那么每种物品买的次数实际上是随着i的增大而递减的。存在单调性。可以枚举每个power，O(1)求出。

SRM 650 Div1 Med
一棵h=10层的平衡二叉树，在里面加上三条边。给出加边后的图，问去掉三条边后原图是否为平衡二叉树。
Solution:
首先去掉自环和重边。
然后就是先看deg = 1的点，必然为叶子节点。然后两个叶子节点所连接的deg<=3的点必然为合法（所连边不需要删掉）的非叶节点。
把这些点所连的边不考虑之后，可以去掉的边实际上并不多。
证明就是，考察一棵层数较少的平衡二叉树，考虑最坏的情况（也就是可去掉边最多的情况），必然是多出来的三条边加在叶子之间（因为底层的可以影响高层的节点）。
然后要使影响的范围尽量大，多加的边连接的两个叶子节点的LCA就要尽量往上。那么最终加的三条边一定是对称分布在叶节点之间。
然后层数增加一层，可以发现最多增加6条可删的边。因此最终可删的边不会超过70。那么,就可以直接枚举了.
把这些可删的边找出来，C(m,3)枚举即可。注意判平衡二叉树的时候，丢进去的图可能有环！
还有一个小技巧就是在用叶子节点找合法的非叶节点的时候，可以枚举层数，然后最多找h层就能把这些点全部找出来。

SRM 651 Div2 Hard
10*10的矩阵，有一些空白'.'和一些障碍'#'。有k<=8个狐狸要去占领空白，要求k个所占位置联通。问方案数。
Solution:
数据规模小，直接dfs。枚举每个位置u选，用$代替，以此为起点dfs出去。dfs的时候枚举各个位置v选或不选。返回后将u标记为＃之后彻底无视这个点。

SRM 668 Div1 Med
n(n<=2000)个点，m(m<=2000)条边的有向图，问是否可能k从某个值开始，不管k多大，都存在一条从0到1长度为k的路径和从1到0长度为k的路径。
Solution：
从0到1和从1到0的路径上必然都有环。且因为来回路径长度都为k，则两环长度gcd=1。那么也就是说经过0的所有环的环长的gcd必须都为1。
则从0开始bfs，找出所有len<=3n的环求gcd。

SRM 685 Div1 Med(dfs+结论)
SRM 695 Div1 Med(搜索)

SRM 716 Div1 Med / Div2 Hard
n(n<=2000)个顶点的一棵树，从0开始，每次选一个点走过去，一共选m个。把m个travel距离记下来，放到set里，记为D(|D|<=2000)。
问是否存在一个长m的travel路径，能得到D。
Solution：
从0开始bfs。只遍历距离在D中的顶点。然后两两check遍历过的顶点，看是否能cover到D中的所有距离。

TCO17 R1A Div1 Med
A*B*C(A,B,C<=100)的一个cube，每次选一块切一刀，要求切后坐标为整。问切出来的所有最短边>=S(S<=10)的cube中，另外两边XY乘积和的最大值是多少。
Solution：
看看sample。
1.不允许有最短边<S的块。否则浪费。
2.能切的边里，尽量均分。

SRM 734 Div1 Med
牌堆中有10种牌，其中1可以看作11。牌堆中每种牌有0-4张，总数不超过16张。
player有两张明牌，dealer有一张明牌。
player可以选择从牌堆中摸牌或者停，但超过21则必须停。
dealer首先将1看作11，如果总和在17到21之间则停止摸牌；否则将1看作1，超过21则输掉，否则必须继续摸牌。
最终两边停止时，dealer大于21则player直接赢；否则如果player总和未超21且大于dealer，则player赢，反之dealer赢。
问player赢的概率。
Solution：
直接暴力+记忆化搜。
最多只有一张ace(11)。dp1[sum][ace][deck]表示player和为sum，有没有ace，牌堆状态为deck时player赢的概率。
那么每次枚举player摸牌或者不摸，然后求出dealer的和取所有值的概率。同样记忆化dp2[sum][ace][deck]，不过这里面存的是长度为0-21的vector表示概率。
